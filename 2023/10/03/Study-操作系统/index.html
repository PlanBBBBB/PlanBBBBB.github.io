<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>操作系统 | PlanB's Blog</title><meta name="author" content="PlanB,2741718884@qq.com"><meta name="copyright" content="PlanB"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="操作系统相关学习">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="https://planbbbbb.github.io/2023/10/03/Study-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="PlanB&#39;s Blog">
<meta property="og:description" content="操作系统相关学习">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://planbbbbb.github.io/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.png">
<meta property="article:published_time" content="2023-10-03T13:30:58.476Z">
<meta property="article:modified_time" content="2024-06-10T14:14:14.049Z">
<meta property="article:author" content="PlanB">
<meta property="article:tag" content="408">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://planbbbbb.github.io/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.png"><link rel="shortcut icon" href="/./img/%E9%A5%AE%E6%96%99.png"><link rel="canonical" href="https://planbbbbb.github.io/2023/10/03/Study-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-10 22:14:14'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/%E5%A4%B4%E5%83%8F.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">52</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/../img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">PlanB's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-03T13:30:58.476Z" title="发表于 2023-10-03 21:30:58">2023-10-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-10T14:14:14.049Z" title="更新于 2024-06-10 22:14:14">2024-06-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Study/">Study</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>[TOC]</p>
<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本篇文章学习自<a target="_blank" rel="noopener" href="https://xiaolincoding.com/os/">https://xiaolincoding.com/os/</a> 和Javaguide</p>
<p>面试题：</p>
<ol>
<li>fork()调用系统底层发生了什么？</li>
<li>子进程可以访问父进程的全局变量吗？（不可以）</li>
<li>进程间通信方式？</li>
<li>缺页中断。</li>
</ol>
<h1 id="硬件结构"><a href="#硬件结构" class="headerlink" title="硬件结构"></a>硬件结构</h1><h2 id="冯诺依曼模型"><a href="#冯诺依曼模型" class="headerlink" title="冯诺依曼模型"></a>冯诺依曼模型</h2><p>最重要的是定义计算机基本结构为 5 个部分，分别是<strong>运算器、控制器、存储器、输入设备、输出设备</strong>，这 5 个部分也被称为<strong>冯诺依曼模型</strong>。</p>
<p><img src="/../assets/Study-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240601220846287.png" alt="image-20240601220846287"></p>
<p>运算器、控制器是在中央处理器里的，存储器就我们常见的内存，输入输出设备则是计算机外接的设备，比如键盘就是输入设备，显示器就是输出设备。</p>
<p>存储单元和输入输出设备要与中央处理器打交道的话，离不开总线。所以，它们之间的关系如下图：</p>
<p><img src="/../assets/Study-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%A8%A1%E5%9E%8B.png" alt="img"></p>
<p>CPU 内部还有一些组件，常见的有<strong>寄存器、控制单元和逻辑运算单元</strong>等。其中，控制单元负责控制 CPU 工作，逻辑运算单元负责计算，而寄存器可以分为多种类，每种寄存器的功能又不尽相同。</p>
<p>常见的寄存器种类：</p>
<ul>
<li><em>通用寄存器</em>，用来存放需要进行运算的数据，比如需要进行加和运算的两个数据。</li>
<li><em>程序计数器</em>，用来存储 CPU 要执行下一条指令「所在的内存地址」，注意不是存储了下一条要执行的指令，此时指令还在内存中，程序计数器只是存储了下一条指令「的地址」。</li>
<li><em>指令寄存器</em>，用来存放当前正在执行的指令，也就是指令本身，指令被执行完成之前，指令都存储在这里。</li>
</ul>
<h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><p>总线是用于 CPU 和内存以及其他设备之间的通信，总线可分为 3 种：</p>
<ul>
<li><em>地址总线</em>，用于指定 CPU 将要操作的内存地址；</li>
<li><em>数据总线</em>，用于读写内存的数据；</li>
<li><em>控制总线</em>，用于发送和接收信号，比如中断、设备复位等信号，CPU 收到信号后自然进行响应，这时也需要控制总线；</li>
</ul>
<p>当 CPU 要读写内存数据的时候，一般需要通过下面这三个总线：</p>
<ul>
<li>首先要通过「地址总线」来指定内存的地址；</li>
<li>然后通过「控制总线」控制是读或写命令；</li>
<li>最后通过「数据总线」来传输数据；</li>
</ul>
<h3 id="程序的执行流程"><a href="#程序的执行流程" class="headerlink" title="程序的执行流程"></a>程序的执行流程</h3><p>程序实际上是一条一条指令，所以程序的运行过程就是把每一条指令一步一步的执行起来，负责执行指令的就是 CPU 了。</p>
<p><img src="/../assets/Study-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CPU%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F.png" alt="img"></p>
<p>那 CPU 执行程序的过程如下：</p>
<ul>
<li>第一步，CPU 读取「程序计数器」的值，这个值是指令的内存地址，然后 CPU 的「控制单元」操作「地址总线」指定需要访问的内存地址，接着通知内存设备准备数据，数据准备好后通过「数据总线」将指令数据传给 CPU，CPU 收到内存传来的数据后，将这个指令数据存入到「指令寄存器」。</li>
<li>第二步，「程序计数器」的值自增，表示指向下一条指令。这个自增的大小，由 CPU 的位宽决定，比如 32 位的 CPU，指令是 4 个字节，需要 4 个内存地址存放，因此「程序计数器」的值会自增 4；</li>
<li>第三步，CPU 分析「指令寄存器」中的指令，确定指令的类型和参数，如果是计算类型的指令，就把指令交给「逻辑运算单元」运算；如果是存储类型的指令，则交由「控制单元」执行；</li>
</ul>
<p>简单总结一下就是，一个程序执行的时候，CPU 会根据程序计数器里的内存地址，从内存里面把需要执行的指令读取到指令寄存器里面执行，然后根据指令长度自增，开始顺序读取下一条指令。</p>
<p>CPU 从程序计数器读取指令、到执行、再到下一条指令，这个过程会不断循环，直到程序执行结束，这个不断循环的过程被称为 <strong>CPU 的指令周期</strong>。</p>
<h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><p><img src="/../assets/Study-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240601221333415.png" alt="image-20240601221333415"></p>
<p><strong>对于存储器，它的速度越快、能耗会越高、而且材料的成本也是越贵的，以至于速度快的存储器的容量都比较小。</strong></p>
<p>其中，存储空间越大的存储器设备，其访问速度越慢，所需成本也相对越少。</p>
<p>CPU 并不会直接和每一种存储器设备直接打交道，而是每一种存储器设备只和它相邻的存储器设备打交道。</p>
<p>比如，CPU Cache 的数据是从内存加载过来的，写回数据的时候也只写回到内存，CPU Cache 不会直接把数据写到硬盘，也不会直接从硬盘加载数据，而是先加载到内存，再从内存加载到 CPU Cache 中。</p>
<p><img src="/../assets/Study-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="img"></p>
<p>所以，<mark><strong>每个存储器只和相邻的一层存储器设备打交道，并且存储设备为了追求更快的速度，所需的材料成本必然也是更高，也正因为成本太高，所以 CPU 内部的寄存器、L1\L2\L3 Cache 只好用较小的容量，相反内存、硬盘则可用更大的容量，这就我们今天所说的存储器层次结构</strong></mark>。</p>
<h2 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h2><p>什么是内核呢？</p>
<p>计算机是由各种外部硬件设备组成的，比如内存、cpu、硬盘等，如果每个应用都要和这些硬件设备对接通信协议，那这样太累了，所以这个中间人就由内核来负责，<strong>让内核作为应用连接硬件设备的桥梁</strong>，应用程序只需关心与内核交互，不用关心硬件的细节。</p>
<p><img src="/../assets/Study-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Kernel_Layout.png" alt="内核"></p>
<p><strong><mark>内核有哪些能力呢？</mark></strong></p>
<p>现代操作系统，内核一般会提供 4 个基本能力：</p>
<ul>
<li>管理进程、线程，决定哪个进程、线程使用 CPU，也就是<strong>进程调度的能力</strong>；</li>
<li>管理内存，决定内存的分配和回收，也就是<strong>内存管理的能力</strong>；</li>
<li>管理硬件设备，为进程与硬件设备之间提供通信能力，也就是<strong>硬件通信能力</strong>；</li>
<li>提供<strong>系统调用</strong>，如果应用程序要运行更高权限运行的服务，那么就需要有系统调用，它是用户程序与操作系统之间的接口。</li>
</ul>
<p><strong><mark>内核是怎么工作的？</mark></strong></p>
<p>内核具有很高的权限，可以控制 cpu、内存、硬盘等硬件，而应用程序具有的权限很小，因此大多数操作系统，把内存分成了两个区域：</p>
<ul>
<li>内核空间，这个内存空间只有内核程序可以访问；</li>
<li>用户空间，这个内存空间专门给应用程序使用；</li>
</ul>
<p>用户空间的代码只能访问一个局部的内存空间，而内核空间的代码可以访问所有内存空间。因此，当程序使用用户空间时，我们常说该程序在<strong>用户态</strong>执行，而当程序使内核空间时，程序则在<strong>内核态</strong>执行。</p>
<p>应用程序如果需要进入内核空间，就需要通过系统调用，下面来看看系统调用的过程：</p>
<p><img src="/../assets/Study-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/systemcall.png" alt="img"></p>
<p>内核程序执行在内核态，用户程序执行在用户态。当应用程序使用系统调用时，会产生一个中断。发生中断后， CPU 会中断当前在执行的用户程序，转而跳转到中断处理程序，也就是开始执行内核程序。内核处理完后，主动触发中断，把 CPU 执行权限交回给用户程序，回到用户态继续工作</p>
<h2 id="CPU缓存一致性"><a href="#CPU缓存一致性" class="headerlink" title="CPU缓存一致性"></a>CPU缓存一致性</h2><p>CPU 在读写数据的时候，都是在 CPU Cache 读写数据的，原因是 Cache 离 CPU 很近，读写性能相比内存高出很多。对于 Cache 里没有缓存 CPU 所需要读取的数据的这种情况，CPU 则会从内存读取数据，并将数据缓存到 Cache 里面，最后 CPU 再从 Cache 读取数据。</p>
<p>而对于数据的写入，CPU 都会先写入到 Cache 里面，然后再在找个合适的时机写入到内存，那就有「写直达」和「写回」这两种策略来保证 Cache 与内存的数据一致性：</p>
<ul>
<li>写直达，只要有数据写入，都会直接把数据写入到内存里面，这种方式简单直观，但是性能就会受限于内存的访问速度；</li>
<li>写回，对于已经缓存在 Cache 的数据的写入，只需要更新其数据就可以，不用写入到内存，只有在需要把缓存里面的脏数据交换出去的时候，才把数据同步到内存里，这种方式在缓存命中率高的情况，性能会更好；</li>
</ul>
<p><strong>当今 CPU 都是多核的，每个核心都有各自独立的 L1&#x2F;L2 Cache，只有 L3 Cache 是多个核心之间共享的。所以，我们要确保多核缓存是一致性的，否则会出现错误的结果。</strong></p>
<p>要想实现缓存一致性，关键是要满足 2 点：</p>
<ul>
<li>第一点是写传播，也就是当某个 CPU 核心发生写入操作时，需要把该事件广播通知给其他核心；</li>
<li>第二点是事物的串行化，这个很重要，只有保证了这个，才能保障我们的数据是真正一致的，我们的程序在各个不同的核心上运行的结果也是一致的；</li>
</ul>
<p>**<mark>基于总线嗅探机制的 MESI 协议</mark>**，就满足上面了这两点，因此它是保障缓存一致性的协议。</p>
<p>MESI 协议，是已修改、独占、共享、已失效这四个状态的英文缩写的组合。整个 MSI 状态的变更，则是根据来自本地 CPU 核心的请求，或者来自其他 CPU 核心通过总线传输过来的请求，从而构成一个流动的状态机。另外，对于在「已修改」或者「独占」状态的 Cache Line，修改更新其数据不需要发送广播给其他 CPU 核心。</p>
<p>🔴🟢🟡补充：</p>
<p>CPU缓存一致性（Cache Coherence）是指在多处理器系统中，保证各个处理器缓存中的数据与主存中的数据保持一致，以防止不同处理器读取到不同版本的数据。CPU缓存一致性问题通常出现在多核处理器或多处理器系统中，每个处理器都有自己的缓存。当多个处理器并发地读取和写入共享内存区域时，必须确保缓存数据的一致性。</p>
<h3 id="缓存一致性问题"><a href="#缓存一致性问题" class="headerlink" title="缓存一致性问题"></a>缓存一致性问题</h3><p>缓存一致性问题可以描述为以下几种典型情景：</p>
<ol>
<li><p><strong>写失效（Write Invalidation）：</strong></p>
<ul>
<li>处理器A将数据写入自己的缓存，但处理器B的缓存中仍保留旧数据。这会导致数据不一致。</li>
</ul>
</li>
<li><p><strong>写更新（Write Update）：</strong></p>
<ul>
<li>处理器A将数据写入自己的缓存并更新内存，处理器B的缓存需要同步更新此数据，以确保一致性。</li>
</ul>
</li>
</ol>
<h3 id="缓存一致性协议"><a href="#缓存一致性协议" class="headerlink" title="缓存一致性协议"></a>缓存一致性协议</h3><p>为了解决缓存一致性问题，现代处理器通常采用缓存一致性协议（Cache Coherence Protocols）。最常见的缓存一致性协议有以下几种：</p>
<ol>
<li><p><strong>MSI协议（Modified, Shared, Invalid）：</strong></p>
<ul>
<li>数据在缓存中的状态可以是Modified（已修改）、Shared（共享）、Invalid（无效）三种状态。</li>
<li>当处理器对数据进行写操作时，会将该数据标记为Modified，并使其他缓存中相同数据变为Invalid。</li>
</ul>
</li>
<li><p><strong>MESI协议（Modified, Exclusive, Shared, Invalid）：</strong></p>
<ul>
<li>在MSI的基础上增加了Exclusive状态，表示该数据只存在于一个缓存中且未被修改。</li>
<li>处理器在读取数据时，如果该数据在缓存中是Exclusive状态，则可以直接使用，无需访问主存。</li>
</ul>
</li>
<li><p><strong>MOESI协议（Modified, Owner, Exclusive, Shared, Invalid）：</strong></p>
<ul>
<li>在MESI的基础上增加了Owner状态，表示该数据在某个缓存中是最新的版本且共享给其他处理器。</li>
<li>处理器可以从Owner缓存中获取最新数据，而无需访问主存。</li>
</ul>
</li>
<li><p><strong>MESIF协议（Modified, Exclusive, Shared, Invalid, Forward）：</strong></p>
<ul>
<li>在MESI的基础上增加了Forward状态，用于优化读操作。当多个缓存共享同一数据时，Forward状态缓存负责向其他处理器转发数据。</li>
</ul>
</li>
</ol>
<h3 id="缓存一致性操作"><a href="#缓存一致性操作" class="headerlink" title="缓存一致性操作"></a>缓存一致性操作</h3><p>缓存一致性协议通过以下操作来维持一致性：</p>
<ol>
<li><p><strong>嗅探（Snooping）：</strong></p>
<ul>
<li>处理器通过嗅探总线上的通信来监视其他处理器的读写操作。如果检测到其他处理器对共享数据的写操作，缓存行状态会相应地更新。</li>
</ul>
</li>
<li><p><strong>目录协议（Directory-Based Protocols）：</strong></p>
<ul>
<li>系统维护一个目录，记录每个内存块在哪些缓存中存在以及它们的状态。处理器在读写数据时，通过查询目录来更新缓存状态。</li>
</ul>
</li>
<li><p><strong>总线加锁（Bus Locking）：</strong></p>
<ul>
<li>在某些情况下，处理器可以通过锁定总线来保证对数据的独占访问，防止其他处理器干扰。</li>
</ul>
</li>
</ol>
<p>通过这些协议和操作，CPU可以确保各处理器缓存中的数据一致性，避免并发访问导致的数据不一致问题，提高系统的稳定性和性能。</p>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="为什么要有虚拟内存"><a href="#为什么要有虚拟内存" class="headerlink" title="为什么要有虚拟内存"></a>为什么要有虚拟内存</h2><h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="进程和线程共享哪些资源"><a href="#进程和线程共享哪些资源" class="headerlink" title="进程和线程共享哪些资源"></a>进程和线程共享哪些资源</h2><p>共享的资源和不共享的资源划分如下表：</p>
<table>
<thead>
<tr>
<th>资源类型</th>
<th>共享&#x2F;不共享</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>代码段</td>
<td>共享</td>
<td>所有线程执行相同的代码段。</td>
</tr>
<tr>
<td>进程地址空间</td>
<td>共享</td>
<td>包括堆和全局变量，所有线程可以访问和修改。</td>
</tr>
<tr>
<td>打开的文件描述符</td>
<td>共享</td>
<td>所有线程可以访问进程打开的文件和套接字。</td>
</tr>
<tr>
<td>当前工作目录</td>
<td>共享</td>
<td>所有线程共享相同的当前工作目录。</td>
</tr>
<tr>
<td>用户ID和组ID</td>
<td>共享</td>
<td>线程共享相同的用户ID和组ID，具有相同的权限。</td>
</tr>
<tr>
<td>信号处理器</td>
<td>共享</td>
<td>所有线程共享相同的信号处理器。</td>
</tr>
<tr>
<td>定时器</td>
<td>共享</td>
<td>由进程设置的定时器是线程共享的。</td>
</tr>
<tr>
<td>栈</td>
<td>不共享</td>
<td>每个线程有自己的栈，用于存储局部变量和函数调用信息。</td>
</tr>
<tr>
<td>线程局部存储</td>
<td>不共享</td>
<td>每个线程有自己的线程局部存储，用于存储线程特有的数据。</td>
</tr>
<tr>
<td>程序计数器</td>
<td>不共享</td>
<td>每个线程有自己的程序计数器，指示当前执行的指令。</td>
</tr>
<tr>
<td>寄存器</td>
<td>不共享</td>
<td>每个线程有自己的一组寄存器。</td>
</tr>
<tr>
<td>信号掩码</td>
<td>不共享</td>
<td>每个线程可以有自己的信号掩码。</td>
</tr>
<tr>
<td>调度信息</td>
<td>不共享</td>
<td>每个线程可以有自己的优先级和调度属性。</td>
</tr>
</tbody></table>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>进程通信涉及在不同进程之间传递数据或信息。由于进程通常在独立的内存空间中运行，它们需要特定的机制来交换数据。**<mark>进程通信的主要目标是数据交换和信息传递，使得多个进程能够协同工作。</mark>**</p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p><strong>匿名管道</strong>顾名思义，它没有名字标识，匿名管道是特殊文件只存在于内存，没有存在于文件系统中，shell 命令中的「<code>|</code>」竖线就是匿名管道，通信的数据是<strong>无格式的流并且大小受限</strong>，通信的方式是<strong>单向</strong>的，数据只能在一个方向上流动，如果要双向通信，需要创建两个管道，再来<strong>匿名管道是只能用于存在父子关系的进程间通信</strong>，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失。</p>
<p><strong>命名管道</strong>突破了匿名管道只能在亲缘关系进程间的通信限制，因为使用命名管道的前提，需要在文件系统创建一个类型为 p 的设备文件，那么毫无关系的进程就可以通过这个设备文件进行通信。另外，不管是匿名管道还是命名管道，进程写入的数据都是<strong>缓存在内核</strong>中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循<strong>先进先出</strong>原则，不支持 lseek 之类的文件定位操作。</p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p><strong>消息队列</strong>克服了管道通信的数据是无格式的字节流的问题，消息队列实际上是保存在内核的「消息链表」，消息队列的消息体是可以用户自定义的数据类型，发送数据时，会被分成一个一个独立的消息体，当然接收数据时，也要与发送方发送的消息体的数据类型保持一致，这样才能保证读取的数据是正确的。消息队列通信的速度不是最及时的，毕竟<strong>每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程。</strong></p>
<h3 id="共享内存-信号量"><a href="#共享内存-信号量" class="headerlink" title="共享内存+信号量"></a>共享内存+信号量</h3><p><strong>共享内存</strong>可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销，<strong>它直接分配一个共享空间，每个进程都可以直接访问</strong>，就像访问进程自己的空间一样快捷方便，不需要陷入内核态或者系统调用，大大提高了通信的速度，享有<strong>最快</strong>的进程间通信方式之名。但是便捷高效的共享内存通信，<strong>带来新的问题，多进程竞争同个共享资源会造成数据的错乱。</strong></p>
<p>那么，就需要<strong>信号量</strong>来保护共享资源，以确保任何时刻只能有一个进程访问共享资源，这种方式就是互斥访问。<strong>信号量不仅可以实现访问的互斥性，还可以实现进程间的同步</strong>，信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 <strong>P 操作和 V 操作</strong>。</p>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>信号是<strong>异步通信机制</strong>，信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令），一旦有信号发生，<strong>进程有三种方式响应信号 1. 执行默认操作、2. 捕捉信号、3. 忽略信号</strong>。有两个信号是应用进程无法捕捉和忽略的，即 <code>SIGKILL</code> 和 <code>SIGSTOP</code>，这是为了方便我们能在任何时候结束或停止某个进程。</p>
<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>如果<strong>要与<mark>不同主机的进程间通信</mark>，那么就需要 Socket 通信了</strong>。Socket 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式。</p>
<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><p>进程同步旨在协调多个进程的执行顺序，以防止数据不一致和竞态条件（Race Conditions）。当多个进程同时访问和操作共享资源时，进程同步是必需的。**<mark>进程同步的主要目标是确保共享资源的完整性和一致性，防止数据冲突和死锁等问题。</mark>**</p>
<p>常用的进程同步机制包括：</p>
<ol>
<li><p>**互斥锁 (Mutexes)**：确保某一时刻只有一个进程能够访问共享资源。</p>
</li>
<li><p>**信号量 (Semaphores)**：可以用来限制对多个资源的访问，分为计数信号量和二进制信号量。</p>
</li>
<li><p>**条件变量 (Condition Variables)**：用于进程等待特定条件变为真时再继续执行。</p>
</li>
<li><p>**读写锁 (Read-Write Locks)**：允许多读单写的访问模式，提高并发性。</p>
</li>
</ol>
<h2 id="PCB-是什么？包含哪些信息？"><a href="#PCB-是什么？包含哪些信息？" class="headerlink" title="PCB 是什么？包含哪些信息？"></a>PCB 是什么？包含哪些信息？</h2><p><strong>PCB（Process Control Block）</strong> 即进程控制块，是操作系统中用来管理和跟踪进程的数据结构，每个进程都对应着一个独立的 PCB。你可以将 PCB 视为进程的大脑。</p>
<p>当操作系统创建一个新进程时，会为该进程分配一个唯一的进程 ID，并且为该进程创建一个对应的进程控制块。当进程执行时，PCB 中的信息会不断变化，操作系统会根据这些信息来管理和调度进程。</p>
<p>PCB 主要包含下面几部分的内容：</p>
<ul>
<li>进程的描述信息，包括进程的名称、标识符等等；</li>
<li>进程的调度信息，包括进程阻塞原因、进程状态（就绪、运行、阻塞等）、进程优先级（标识进程的重要程度）等等；</li>
<li>进程对资源的需求情况，包括 CPU 时间、内存空间、I&#x2F;O 设备等等。</li>
<li>进程打开的文件信息，包括文件描述符、文件类型、打开模式等等。</li>
<li>处理机的状态信息（由处理机的各种寄存器中的内容组成的），包括通用寄存器、指令计数器、程序状态字 PSW、用户栈指针。</li>
</ul>
<blockquote>
<p>每个 PCB 是如何组织的呢？</p>
</blockquote>
<p>通常是通过<strong>链表</strong>的方式进行组织，把具有<strong>相同状态的进程链在一起，组成各种队列</strong>。比如：</p>
<ul>
<li>将所有处于就绪状态的进程链在一起，称为<strong>就绪队列</strong>；</li>
<li>把所有因等待某事件而处于等待状态的进程链在一起就组成各种<strong>阻塞队列</strong>；</li>
<li>另外，对于运行队列在单核 CPU 系统中则只有一个运行指针了，因为单核 CPU 在某个时间，只能运行一个程序。</li>
</ul>
<p>那么，就绪队列和阻塞队列链表的组织形式如下图：</p>
<p><img src="/../assets/Study-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/12-PCB%E7%8A%B6%E6%80%81%E9%93%BE%E8%A1%A8%E7%BB%84%E7%BB%87.jpg" alt="就绪队列和阻塞队列"></p>
<p>除了链接的组织方式，还有索引方式，它的工作原理：将同一状态的进程组织在一个索引表中，索引表项指向相应的 PCB，不同状态对应不同的索引表。</p>
<p>一般会选择链表，因为可能面临进程创建，销毁等调度导致进程状态发生变化，所以链表能够更加灵活的插入和删除。</p>
<h2 id="进程有哪几种状态"><a href="#进程有哪几种状态" class="headerlink" title="进程有哪几种状态?"></a>进程有哪几种状态?</h2><p>我们一般把进程大致分为 5 种状态，这一点和线程很像！</p>
<ul>
<li>**创建状态(new)**：进程正在被创建，尚未到就绪状态。</li>
<li>**就绪状态(ready)<strong>：进程已处于准备运行状态，即</strong><mark>进程获得了除了处理器之外的一切所需资源</mark>**，一旦得到处理器资源(处理器分配的时间片)即可运行。</li>
<li>**运行状态(running)**：进程正在处理器上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。</li>
<li>**阻塞状态(waiting)**：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。</li>
<li>**结束状态(terminated)**：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。</li>
</ul>
<p><img src="/../assets/Study-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/state-transition-of-process.png" alt="进程状态图转换图"></p>
<hr>
<p><img src="/../assets/Study-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/10-%E8%BF%9B%E7%A8%8B%E4%B8%83%E4%B8%AD%E7%8A%B6%E6%80%81.jpg" alt="七种状态变迁"></p>
<h2 id="进程的控制"><a href="#进程的控制" class="headerlink" title="进程的控制"></a>进程的控制</h2><p>我们熟知了进程的状态变迁和进程的数据结构 PCB 后，再来看看进程的<strong>创建、终止、阻塞、唤醒</strong>的过程，这些过程也就是进程的控制。</p>
<p><strong>01 创建进程</strong></p>
<p>操作系统允许一个进程创建另一个进程，而且允许子进程继承父进程所拥有的资源。</p>
<p><mark>创建进程的过程如下：</mark></p>
<ul>
<li>申请一个空白的 PCB，并向 PCB 中填写一些控制和管理进程的信息，比如进程的唯一标识等；</li>
<li>为该进程分配运行时所必需的资源，比如内存资源；</li>
<li>将 PCB 插入到就绪队列，等待被调度运行；</li>
</ul>
<p><strong>02 终止进程</strong></p>
<p>进程可以有 3 种终止方式：正常结束、异常结束以及外界干预（信号 <code>kill</code> 掉）。</p>
<p>当子进程被终止时，其在父进程处继承的资源应当还给父进程。而当父进程被终止时，该父进程的子进程就变为孤儿进程，会被 1 号进程收养，并由 1 号进程对它们完成状态收集工作。</p>
<p><mark>终止进程的过程如下：</mark></p>
<ul>
<li>查找需要终止的进程的 PCB；</li>
<li>如果处于执行状态，则立即终止该进程的执行，然后将 CPU 资源分配给其他进程；</li>
<li>如果其还有子进程，则应将该进程的子进程交给 1 号进程接管；</li>
<li>将该进程所拥有的全部资源都归还给操作系统；</li>
<li>将其从 PCB 所在队列中删除；</li>
</ul>
<p><strong>03 阻塞进程</strong></p>
<p>当进程需要等待某一事件完成时，它可以调用阻塞语句把自己阻塞等待。而一旦被阻塞等待，它只能由另一个进程唤醒。</p>
<p><mark>阻塞进程的过程如下：</mark></p>
<ul>
<li>找到将要被阻塞进程标识号对应的 PCB；</li>
<li>如果该进程为运行状态，则保护其现场，将其状态转为阻塞状态，停止运行；</li>
<li>将该 PCB 插入到阻塞队列中去；</li>
</ul>
<p><strong>04 唤醒进程</strong></p>
<p>进程由「运行」转变为「阻塞」状态是由于进程必须等待某一事件的完成，所以处于阻塞状态的进程是绝对不可能叫醒自己的。</p>
<p>如果某进程正在等待 I&#x2F;O 事件，需由别的进程发消息给它，则只有当该进程所期待的事件出现时，才由发现者进程用唤醒语句叫醒它。</p>
<p><mark>唤醒进程的过程如下：</mark></p>
<ul>
<li>在该事件的阻塞队列中找到相应进程的 PCB；</li>
<li>将其从阻塞队列中移出，并置其状态为就绪状态；</li>
<li>把该 PCB 插入到就绪队列中，等待调度程序调度；</li>
</ul>
<p>进程的阻塞和唤醒是一对功能相反的语句，如果某个进程调用了阻塞语句，则必有一个与之对应的唤醒语句。</p>
<h2 id="线程相比进程能减少开销"><a href="#线程相比进程能减少开销" class="headerlink" title="线程相比进程能减少开销"></a>线程相比进程能减少开销</h2><blockquote>
<p><strong>线程是调度的基本单位，而进程则是资源拥有的基本单位</strong>。</p>
</blockquote>
<p>对于，线程相比进程能减少开销，体现在：</p>
<ul>
<li>线程的创建时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们；</li>
<li>线程的终止时间比进程快，因为线程释放的资源相比进程少很多；</li>
<li><strong><mark>同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的；</mark></strong></li>
<li>由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了；</li>
</ul>
<p>所以，不管是时间效率，还是空间效率线程比进程都要高。</p>
<h2 id="协程与线程和进程的对比"><a href="#协程与线程和进程的对比" class="headerlink" title="协程与线程和进程的对比"></a>协程与线程和进程的对比</h2><p>协程（Coroutine）是操作系统和编程语言中一种用于并发编程的技术，它允许在执行过程中暂停和恢复函数，提供比传统线程更轻量级的并发机制。协程有几个关键特点，使其与线程和进程有显著区别。</p>
<h3 id="协程的特点"><a href="#协程的特点" class="headerlink" title="协程的特点"></a>协程的特点</h3><ol>
<li><strong>轻量级</strong>：协程的创建和切换开销非常小，通常仅仅是函数调用和返回的开销，不需要像线程那样依赖操作系统调度和上下文切换。</li>
<li><strong>用户态切换</strong>：协程的切换是在用户态完成的，不涉及内核态操作，避免了线程切换时的上下文切换开销。</li>
<li><strong>非抢占式</strong>：协程的切换是协作式的，即协程主动让出执行权，而不是由操作系统抢占。</li>
<li><strong>状态保存</strong>：协程在暂停执行时保存当前执行的状态（如局部变量和程序计数器），在恢复时从保存的状态继续执行。</li>
</ol>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ul>
<li><strong>线程</strong>：由操作系统管理，支持真正的并行执行（在多核处理器上），但创建和上下文切换开销较大，容易产生竞态条件和死锁问题。</li>
<li><strong>进程</strong>：独立的内存空间，隔离性强，适合执行完全独立的任务，但创建和通信开销更大。</li>
<li><strong>协程</strong>：用户态管理，轻量级，适合I&#x2F;O密集型任务和高并发场景，但不适合CPU密集型任务，因为单线程内的协程无法并行执行。</li>
</ul>
<p>总之，协程通过提供一种轻量级的并发机制，简化了异步编程模型，提高了程序的执行效率，特别适合I&#x2F;O密集型和高并发任务。</p>
<h2 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h2><p>线程的实现方式主要包括用户线程、内核线程和轻量级进程（LWP）。每种实现方式在管理、调度和性能方面都有不同的特点和适用场景。以下是对这三种线程的详细解释。</p>
<h3 id="1-用户线程（User-Thread）"><a href="#1-用户线程（User-Thread）" class="headerlink" title="1. 用户线程（User Thread）"></a>1. 用户线程（User Thread）</h3><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul>
<li><strong>用户空间实现</strong>：用户线程在用户空间中实现，由用户态的线程库管理和调度，而不是由操作系统内核管理。</li>
<li><strong>轻量级</strong>：由于线程的创建、切换和同步在用户态完成，开销较小，效率较高。</li>
<li><strong>不可抢占</strong>：用户线程的调度由用户程序控制，通常采用协作式调度，线程主动让出控制权。</li>
<li><strong>无内核干预</strong>：内核对用户线程不可见，线程切换不涉及内核态，因此不会引起内核上下文切换。</li>
</ul>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul>
<li><strong>高效</strong>：线程操作在用户态进行，避免了系统调用的开销。</li>
<li><strong>灵活</strong>：用户程序可以自定义调度策略，适应特定应用需求。</li>
</ul>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul>
<li><strong>阻塞问题</strong>：如果一个用户线程进行阻塞系统调用（如I&#x2F;O操作），整个进程都会被阻塞，因为内核无法识别和调度其他线程。</li>
<li><strong>多核利用不足</strong>：用户线程无法利用多处理器系统的并行计算能力，因为内核只看到一个单一的进程。</li>
</ul>
<h3 id="2-内核线程（Kernel-Thread）"><a href="#2-内核线程（Kernel-Thread）" class="headerlink" title="2. 内核线程（Kernel Thread）"></a>2. 内核线程（Kernel Thread）</h3><h4 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h4><ul>
<li><strong>内核空间实现</strong>：内核线程在内核空间实现，由操作系统内核直接管理和调度。</li>
<li><strong>抢占式调度</strong>：内核线程可以被操作系统内核抢占和调度，支持多任务并发。</li>
<li><strong>可见性</strong>：内核线程对操作系统内核可见，内核可以识别和管理每个线程的状态。</li>
</ul>
<h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><ul>
<li><strong>阻塞处理</strong>：内核线程的阻塞操作不会影响其他线程的执行，因为内核可以调度其他可运行的线程。</li>
<li><strong>多核支持</strong>：内核线程可以在多个处理器上并行执行，充分利用多核系统的计算能力。</li>
</ul>
<h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><ul>
<li><strong>高开销</strong>：线程的创建、切换和同步需要系统调用，开销较大。</li>
<li><strong>复杂性</strong>：内核线程的管理和调度需要操作系统内核的支持，增加了实现的复杂性。</li>
</ul>
<h3 id="3-轻量级进程（LightWeight-Process-LWP）"><a href="#3-轻量级进程（LightWeight-Process-LWP）" class="headerlink" title="3. 轻量级进程（LightWeight Process, LWP）"></a>3. 轻量级进程（LightWeight Process, LWP）</h3><h4 id="特点：-2"><a href="#特点：-2" class="headerlink" title="特点："></a>特点：</h4><ul>
<li><strong>混合实现</strong>：轻量级进程是一种内核支持用户线程的实现方式，它在内核中为每个用户线程创建一个内核线程，从而提供用户线程的灵活性和内核线程的性能。</li>
<li><strong>一对一模型</strong>：每个用户线程对应一个内核线程，操作系统内核负责调度和管理这些内核线程。</li>
</ul>
<h4 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h4><ul>
<li><strong>综合优势</strong>：结合了用户线程和内核线程的优点，既有用户线程的高效性，又有内核线程的阻塞处理和多核支持能力。</li>
<li><strong>并发性</strong>：支持多线程的并发执行，能够充分利用多处理器资源。</li>
</ul>
<h4 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h4><ul>
<li><strong>开销较高</strong>：每个用户线程都需要一个对应的内核线程，因此线程管理的开销较高。</li>
<li><strong>复杂性</strong>：实现和调度都较为复杂，需要操作系统和线程库的协同工作。</li>
</ul>
<h3 id="线程实现方式总结"><a href="#线程实现方式总结" class="headerlink" title="线程实现方式总结"></a>线程实现方式总结</h3><table>
<thead>
<tr>
<th>特点</th>
<th>用户线程（User Thread）</th>
<th>内核线程（Kernel Thread）</th>
<th>轻量级进程（LightWeight Process, LWP）</th>
</tr>
</thead>
<tbody><tr>
<td>实现位置</td>
<td>用户空间</td>
<td>内核空间</td>
<td>混合实现（内核支持用户线程）</td>
</tr>
<tr>
<td>调度方式</td>
<td>用户态库调度</td>
<td>内核调度</td>
<td>内核调度</td>
</tr>
<tr>
<td>线程可见性</td>
<td>内核不可见</td>
<td>内核可见</td>
<td>内核可见</td>
</tr>
<tr>
<td>阻塞处理</td>
<td>整个进程阻塞</td>
<td>不影响其他线程</td>
<td>不影响其他线程</td>
</tr>
<tr>
<td>多核支持</td>
<td>利用不足</td>
<td>充分利用</td>
<td>充分利用</td>
</tr>
<tr>
<td>操作开销</td>
<td>低</td>
<td>高</td>
<td>较高</td>
</tr>
<tr>
<td>应用场景</td>
<td>适用于轻量级并发</td>
<td>适用于高并发和阻塞操作</td>
<td>综合高效并发和多核支持</td>
</tr>
</tbody></table>
<p>理解这三种线程实现方式的差异有助于在实际应用中选择合适的并发编程模型，以充分利用系统资源，提高程序性能和响应速度。</p>
<h3 id="协程和用户线程对比"><a href="#协程和用户线程对比" class="headerlink" title="协程和用户线程对比"></a>协程和用户线程对比</h3><p>协程和用户线程确实有许多相似之处，但它们并不是完全相同的概念。以下是协程和用户线程的详细对比，帮助理解它们的相似性和差异。</p>
<h4 id="相似之处"><a href="#相似之处" class="headerlink" title="相似之处"></a>相似之处</h4><ol>
<li><strong>用户态管理</strong>：协程和用户线程都在用户态实现和管理，不依赖于操作系统内核的调度。</li>
<li><strong>轻量级</strong>：两者都具有轻量级的特点，创建和切换的开销较小。</li>
<li><strong>非抢占式</strong>：通常都采用非抢占式调度方式，需要主动让出执行权。</li>
</ol>
<h4 id="差异"><a href="#差异" class="headerlink" title="差异"></a>差异</h4><ol>
<li><p><strong>调度模型</strong>：</p>
<ul>
<li><strong>用户线程</strong>：由用户态的线程库进行管理和调度，线程调度通常需要显式调用库函数来切换上下文。用户线程更像是轻量级的线程，多个用户线程可能映射到一个内核线程，依赖操作系统的线程模型。</li>
<li><strong>协程</strong>：协程是更加灵活的控制流结构，可以在函数内部挂起和恢复执行。调度更细粒度，可以在任意位置暂停和恢复。协程的切换通常是通过语言内置的关键字或库函数实现的，调度完全在应用程序控制之下。</li>
</ul>
</li>
<li><p><strong>执行模型</strong>：</p>
<ul>
<li><strong>用户线程</strong>：通常有自己的栈空间和上下文，可以被调度执行类似于独立的执行单元。</li>
<li><strong>协程</strong>：更像是具有可保存状态的函数，执行到<code>yield</code>或<code>await</code>等关键字时挂起，再次调用时从挂起处继续执行。协程共享同一个线程的栈空间，切换时只保存和恢复少量的状态信息。</li>
</ul>
</li>
<li><p><strong>并发性</strong>：</p>
<ul>
<li><strong>用户线程</strong>：多个用户线程可能会在不同的内核线程上并发执行（取决于底层实现），适合多核并行计算。</li>
<li><strong>协程</strong>：通常在单个线程内调度，不涉及真正的并行执行。适用于大量I&#x2F;O操作和高并发场景，但不适合CPU密集型任务。</li>
</ul>
</li>
<li><p><strong>实现复杂性</strong>：</p>
<ul>
<li><strong>用户线程</strong>：需要显式管理线程创建、同步和调度，编程模型类似于多线程编程。</li>
<li><strong>协程</strong>：提供了更高层次的抽象，简化了异步和并发编程，编写协程通常更简单直观。</li>
</ul>
</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>协程和用户线程虽然都在用户态实现，且具有轻量级和高效的特点，但它们在调度模型、执行方式和适用场景上有显著区别：</p>
<ul>
<li><strong>协程</strong>：更适合处理异步I&#x2F;O操作和高并发任务，提供细粒度的控制流管理，编程模型简洁。</li>
<li><strong>用户线程</strong>：适用于多线程编程模型，需要显式管理线程同步和调度，能更好地利用多核处理器资源。</li>
</ul>
<p>理解这些区别有助于选择合适的并发编程模型，根据具体应用场景和需求决定使用协程还是用户线程。</p>
<h2 id="僵尸线程和孤儿线程"><a href="#僵尸线程和孤儿线程" class="headerlink" title="僵尸线程和孤儿线程"></a>僵尸线程和孤儿线程</h2><p>在操作系统中，僵尸进程和孤儿进程是与进程的生命周期和进程关系管理相关的两种特殊状态。理解它们有助于处理进程间的关系和资源管理问题。</p>
<h3 id="僵尸进程-Zombie-Process"><a href="#僵尸进程-Zombie-Process" class="headerlink" title="僵尸进程 (Zombie Process)"></a>僵尸进程 (Zombie Process)</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>僵尸进程是<mark>已经终止但其终止状态还没有被父进程获取的进程</mark>。当一个进程完成其执行并调用<code>exit</code>系统调用后，它会进入终止状态。操作系统会保留该进程的部分信息（如进程ID和退出状态）以便父进程通过<code>wait</code>系统调用获取。如果父进程没有及时调用<code>wait</code>，该进程的部分信息将保留在系统中，此时该进程被称为僵尸进程。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li><strong>状态</strong>：僵尸进程处于终止状态，不会占用CPU和内存资源，但会占用进程表项（PID）。</li>
<li><strong>识别</strong>：通过命令<code>ps</code>可以看到进程状态为<code>Z</code>（表示Zombie）。</li>
<li><strong>清理</strong>：<mark>父进程调用<code>wait</code>或<code>waitpid</code>获取子进程的终止状态后，系统会清理僵尸进程的资源。如果父进程已经终止，init进程（PID 1）会接管并清理它们。</mark></li>
</ul>
<h3 id="孤儿进程-Orphan-Process"><a href="#孤儿进程-Orphan-Process" class="headerlink" title="孤儿进程 (Orphan Process)"></a>孤儿进程 (Orphan Process)</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>孤儿进程是<mark>其父进程已经终止，但它自己仍然在运行的进程</mark>。当一个父进程终止时，其仍在运行的子进程会成为孤儿进程。这些孤儿进程<mark>会被系统的init进程（PID 1）接管，成为init进程的子进程</mark>。</p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li><strong>状态</strong>：孤儿进程继续运行，不会受父进程终止的影响。</li>
<li><strong>管理</strong>：孤儿进程被init进程接管，init进程会负责对它们进行适当的管理和清理。</li>
</ul>
<p>在这段时间内，可以使用<code>ps</code>命令观察子进程的父进程ID变为1，表示它被init进程接管。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>僵尸进程</strong>：已终止但父进程未获取其状态的进程，不释放进程表项。清理方法是父进程调用<code>wait</code>或<code>waitpid</code>。</li>
<li><strong>孤儿进程</strong>：父进程已终止但进程自身仍在运行的进程，被init进程接管并管理。孤儿进程正常运行，不需要特殊清理。</li>
</ul>
<p>理解和处理僵尸进程和孤儿进程对于系统资源管理和进程关系管理至关重要。</p>
<h2 id="线程崩溃了，进程也会崩溃吗？"><a href="#线程崩溃了，进程也会崩溃吗？" class="headerlink" title="线程崩溃了，进程也会崩溃吗？"></a>线程崩溃了，进程也会崩溃吗？</h2><p>正常情况下，操作系统为了保证系统安全，所以针对非法内存访问会发送一个 SIGSEGV 信号，而操作系统一般会调用默认的信号处理函数（一般会让相关的进程崩溃）。</p>
<p>但如果进程觉得”罪不致死”，那么它也可以选择自定义一个信号处理函数，这样的话它就可以做一些自定义的逻辑，比如记录 crash 信息等有意义的事。</p>
<p>回过头来看为什么虚拟机会针对 StackoverflowError 和 NullPointerException 做额外处理让线程恢复呢，针对 stackoverflow 其实它采用了一种栈回溯的方法保证线程可以一直执行下去，而捕获空指针错误主要是这个错误实在太普遍了。</p>
<p>为了这一个很常见的错误而让 JVM 崩溃那线上的 JVM 要宕机多少次，所以出于工程健壮性的考虑，与其直接让 JVM 崩溃倒不如让线程起死回生，并且将这两个错误&#x2F;异常抛给用户来处理。</p>
<h2 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h2><p>简单来说，死锁问题的产生是由两个或者以上线程并行执行的时候，争夺资源而互相等待造成的。</p>
<p>死锁只有同时满足**<mark>互斥、持有并等待、不可剥夺、环路等待</mark>**这四个条件的时候才会发生。</p>
<p>所以要避免死锁问题，就是要破坏其中一个条件即可，最常用的方法就是使用**<mark>资源有序分配法</mark>**来破坏环路等待条件。</p>
<h1 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h1><h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><h3 id="先来先服务调度算法"><a href="#先来先服务调度算法" class="headerlink" title="先来先服务调度算法"></a>先来先服务调度算法</h3><p>最简单的一个调度算法，就是非抢占式的<strong>先来先服务（*First Come First Severd, FCFS*）算法</strong>了。</p>
<p><img src="/../assets/Study-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/24-%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1.jpg" alt="FCFS 调度算法"></p>
<p>顾名思义，先来后到，<strong>每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。</strong></p>
<p>这似乎很公平，但是当一个长作业先运行了，那么后面的短作业等待的时间就会很长，不利于短作业。</p>
<p>FCFS 对长作业有利，适用于 CPU 繁忙型作业的系统，而不适用于 I&#x2F;O 繁忙型作业的系统。</p>
<h3 id="最短作业优先调度算法"><a href="#最短作业优先调度算法" class="headerlink" title="最短作业优先调度算法"></a>最短作业优先调度算法</h3><p><strong>最短作业优先（*Shortest Job First, SJF*）调度算法</strong>同样也是顾名思义，它会<strong>优先选择运行时间最短的进程来运行</strong>，这有助于提高系统的吞吐量。</p>
<p><img src="/../assets/Study-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/25-%E6%9C%80%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95.jpg" alt="SJF 调度算法"></p>
<p>这显然对长作业不利，很容易造成一种极端现象。</p>
<p>比如，一个长作业在就绪队列等待运行，而这个就绪队列有非常多的短作业，那么就会使得长作业不断的往后推，周转时间变长，致使长作业长期不会被运行。</p>
<h3 id="高响应比优先调度算法"><a href="#高响应比优先调度算法" class="headerlink" title="高响应比优先调度算法"></a>高响应比优先调度算法</h3><p>前面的「先来先服务调度算法」和「最短作业优先调度算法」都没有很好的权衡短作业和长作业。</p>
<p>那么，<strong>高响应比优先 （*Highest Response Ratio Next, HRRN*）调度算法</strong>主要是权衡了短作业和长作业。</p>
<p><strong>每次进行进程调度时，先计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行</strong>，「响应比优先级」的计算公式：</p>
<p><img src="/../assets/Study-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/26-%E5%93%8D%E5%BA%94%E6%AF%94%E5%85%AC%E5%BC%8F.jpg" alt="img"></p>
<p>从上面的公式，可以发现：</p>
<ul>
<li>如果两个进程的「等待时间」相同时，「要求的服务时间」越短，「响应比」就越高，这样短作业的进程容易被选中运行；</li>
<li>如果两个进程「要求的服务时间」相同时，「等待时间」越长，「响应比」就越高，这就兼顾到了长作业进程，因为进程的响应比可以随时间等待的增加而提高，当其等待时间足够长时，其响应比便可以升到很高，从而获得运行的机会；</li>
</ul>
<h3 id="时间片轮转调度算法"><a href="#时间片轮转调度算法" class="headerlink" title="时间片轮转调度算法"></a>时间片轮转调度算法</h3><p>最古老、最简单、最公平且使用最广的算法就是<strong>时间片轮转（*Round Robin, RR*）调度算法</strong>。</p>
<p><img src="/../assets/Study-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/27-%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%AF%A2.jpg" alt="RR 调度算法"></p>
<p><strong>每个进程被分配一个时间段，称为时间片（*Quantum*），即允许该进程在该时间段中运行。</strong></p>
<ul>
<li>如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配另外一个进程；</li>
<li>如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换；</li>
</ul>
<p>另外，时间片的长度就是一个很关键的点：</p>
<ul>
<li>如果时间片设得太短会导致过多的进程上下文切换，降低了 CPU 效率；</li>
<li>如果设得太长又可能引起对短作业进程的响应时间变长。将</li>
</ul>
<p>通常时间片设为 <code>20ms~50ms</code> 通常是一个比较合理的折中值。</p>
<h3 id="最高优先级调度算法"><a href="#最高优先级调度算法" class="headerlink" title="最高优先级调度算法"></a>最高优先级调度算法</h3><p>前面的「时间片轮转算法」做了个假设，即让所有的进程同等重要，也不偏袒谁，大家的运行时间都一样。</p>
<p>但是，对于多用户计算机系统就有不同的看法了，它们希望调度是有优先级的，即希望调度程序能<strong>从就绪队列中选择最高优先级的进程进行运行，这称为最高优先级（*Highest Priority First，HPF*）调度算法</strong>。</p>
<p>进程的优先级可以分为，静态优先级或动态优先级：</p>
<ul>
<li>静态优先级：创建进程时候，就已经确定了优先级了，然后整个运行时间优先级都不会变化；</li>
<li>动态优先级：根据进程的动态变化调整优先级，比如如果进程运行时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升高其优先级，也就是<strong>随着时间的推移增加等待进程的优先级</strong>。</li>
</ul>
<p>该算法也有两种处理优先级高的方法，非抢占式和抢占式：</p>
<ul>
<li>非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程。</li>
<li>抢占式：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行。</li>
</ul>
<p>但是依然有缺点，可能会导致低优先级的进程永远不会运行。</p>
<h3 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h3><p><strong>多级反馈队列（*Multilevel Feedback Queue*）调度算法</strong>是「时间片轮转算法」和「最高优先级算法」的综合和发展。</p>
<p>顾名思义：</p>
<ul>
<li>「多级」表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短。</li>
<li>「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列；</li>
</ul>
<p><img src="/../assets/Study-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/28-%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97.jpg" alt="多级反馈队列"></p>
<p>来看看，它是如何工作的：</p>
<ul>
<li>设置了多个队列，赋予每个队列不同的优先级，每个<strong>队列优先级从高到低</strong>，同时<strong>优先级越高时间片越短</strong>；</li>
<li>新的进程会被放入到第一级队列的末尾，按先来先服务的原则排队等待被调度，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成；</li>
<li>当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行；</li>
</ul>
<p>可以发现，对于短作业可能可以在第一级队列很快被处理完。对于长作业，如果在第一级队列处理不完，可以移入下次队列等待被执行，虽然等待的时间变长了，但是运行时间也会更长了，所以该算法很好的<strong>兼顾了长短作业，同时有较好的响应时间。</strong></p>
<h2 id="页面置换"><a href="#页面置换" class="headerlink" title="页面置换"></a>页面置换</h2><h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h1 id="I-O设备管理"><a href="#I-O设备管理" class="headerlink" title="I&#x2F;O设备管理"></a>I&#x2F;O设备管理</h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://PlanBBBBB.github.io">PlanB</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://planbbbbb.github.io/2023/10/03/Study-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">https://planbbbbb.github.io/2023/10/03/Study-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://PlanBBBBB.github.io" target="_blank">PlanB's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/408/">408</a></div><div class="post_share"><div class="social-share" data-image="/../img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/10/03/Study-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><img class="prev-cover" src="/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">计算机网络</div></div></a></div><div class="next-post pull-right"><a href="/2023/10/03/%E9%9D%A2%E8%AF%95-%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><img class="next-cover" src="/../img/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">常用设计模式</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/10/03/Study-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" title="数据结构与算法"><img class="cover" src="/../img/structure.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-03</div><div class="title">数据结构与算法</div></div></a></div><div><a href="/2023/10/03/Study-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络"><img class="cover" src="/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-03</div><div class="title">计算机网络</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/%E5%A4%B4%E5%83%8F.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">PlanB</div><div class="author-info__description">欢迎来到PlanB的博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">52</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/PlanBBBBB"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/PlanBBBBB" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2741718884@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到PlanB的博客！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="toc-number">1.</span> <span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">硬件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">冯诺依曼模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF"><span class="toc-number">2.1.1.</span> <span class="toc-text">总线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">2.1.2.</span> <span class="toc-text">程序的执行流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text">存储器的层次结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8"><span class="toc-number">2.3.</span> <span class="toc-text">内核</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">2.4.</span> <span class="toc-text">CPU缓存一致性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.1.</span> <span class="toc-text">缓存一致性问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.4.2.</span> <span class="toc-text">缓存一致性协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E6%93%8D%E4%BD%9C"><span class="toc-number">2.4.3.</span> <span class="toc-text">缓存一致性操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number">3.1.</span> <span class="toc-text">为什么要有虚拟内存</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E5%93%AA%E4%BA%9B%E8%B5%84%E6%BA%90"><span class="toc-number">4.1.</span> <span class="toc-text">进程和线程共享哪些资源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">4.2.</span> <span class="toc-text">进程通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93"><span class="toc-number">4.2.1.</span> <span class="toc-text">管道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">4.2.2.</span> <span class="toc-text">消息队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">4.2.3.</span> <span class="toc-text">共享内存+信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7"><span class="toc-number">4.2.4.</span> <span class="toc-text">信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Socket"><span class="toc-number">4.2.5.</span> <span class="toc-text">Socket</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">4.3.</span> <span class="toc-text">进程同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PCB-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E4%BF%A1%E6%81%AF%EF%BC%9F"><span class="toc-number">4.4.</span> <span class="toc-text">PCB 是什么？包含哪些信息？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-number">4.5.</span> <span class="toc-text">进程有哪几种状态?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8E%A7%E5%88%B6"><span class="toc-number">4.6.</span> <span class="toc-text">进程的控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9B%B8%E6%AF%94%E8%BF%9B%E7%A8%8B%E8%83%BD%E5%87%8F%E5%B0%91%E5%BC%80%E9%94%80"><span class="toc-number">4.7.</span> <span class="toc-text">线程相比进程能减少开销</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">4.8.</span> <span class="toc-text">协程与线程和进程的对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">4.8.1.</span> <span class="toc-text">协程的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94"><span class="toc-number">4.8.2.</span> <span class="toc-text">对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">4.9.</span> <span class="toc-text">线程的实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%EF%BC%88User-Thread%EF%BC%89"><span class="toc-number">4.9.1.</span> <span class="toc-text">1. 用户线程（User Thread）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">4.9.1.1.</span> <span class="toc-text">特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-number">4.9.1.2.</span> <span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">4.9.1.3.</span> <span class="toc-text">缺点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%EF%BC%88Kernel-Thread%EF%BC%89"><span class="toc-number">4.9.2.</span> <span class="toc-text">2. 内核线程（Kernel Thread）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A-1"><span class="toc-number">4.9.2.1.</span> <span class="toc-text">特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A-1"><span class="toc-number">4.9.2.2.</span> <span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A-1"><span class="toc-number">4.9.2.3.</span> <span class="toc-text">缺点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%BD%BB%E9%87%8F%E7%BA%A7%E8%BF%9B%E7%A8%8B%EF%BC%88LightWeight-Process-LWP%EF%BC%89"><span class="toc-number">4.9.3.</span> <span class="toc-text">3. 轻量级进程（LightWeight Process, LWP）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A-2"><span class="toc-number">4.9.3.1.</span> <span class="toc-text">特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A-2"><span class="toc-number">4.9.3.2.</span> <span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A-2"><span class="toc-number">4.9.3.3.</span> <span class="toc-text">缺点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="toc-number">4.9.4.</span> <span class="toc-text">线程实现方式总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E5%92%8C%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E5%AF%B9%E6%AF%94"><span class="toc-number">4.9.5.</span> <span class="toc-text">协程和用户线程对比</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E4%BC%BC%E4%B9%8B%E5%A4%84"><span class="toc-number">4.9.5.1.</span> <span class="toc-text">相似之处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%AE%E5%BC%82"><span class="toc-number">4.9.5.2.</span> <span class="toc-text">差异</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.9.5.3.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%83%B5%E5%B0%B8%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%AD%A4%E5%84%BF%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.10.</span> <span class="toc-text">僵尸线程和孤儿线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B-Zombie-Process"><span class="toc-number">4.10.1.</span> <span class="toc-text">僵尸进程 (Zombie Process)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">4.10.1.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">4.10.1.2.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B-Orphan-Process"><span class="toc-number">4.10.2.</span> <span class="toc-text">孤儿进程 (Orphan Process)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-number">4.10.2.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-1"><span class="toc-number">4.10.2.2.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">4.10.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%B4%A9%E6%BA%83%E4%BA%86%EF%BC%8C%E8%BF%9B%E7%A8%8B%E4%B9%9F%E4%BC%9A%E5%B4%A9%E6%BA%83%E5%90%97%EF%BC%9F"><span class="toc-number">4.11.</span> <span class="toc-text">线程崩溃了，进程也会崩溃吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98"><span class="toc-number">4.12.</span> <span class="toc-text">死锁问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">5.1.</span> <span class="toc-text">进程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">5.1.1.</span> <span class="toc-text">先来先服务调度算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">5.1.2.</span> <span class="toc-text">最短作业优先调度算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">5.1.3.</span> <span class="toc-text">高响应比优先调度算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">5.1.4.</span> <span class="toc-text">时间片轮转调度算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%AB%98%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">5.1.5.</span> <span class="toc-text">最高优先级调度算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">5.1.6.</span> <span class="toc-text">多级反馈队列调度算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2"><span class="toc-number">5.2.</span> <span class="toc-text">页面置换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">5.3.</span> <span class="toc-text">磁盘调度算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">6.</span> <span class="toc-text">文件系统</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#I-O%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">I&#x2F;O设备管理</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/06/19/%E9%9D%A2%E7%BB%8F-%E6%B7%B1%E4%BF%A1%E6%9C%8D%E7%AC%94%E8%AF%95/" title="深信服笔试"><img src="/../img/%E6%B7%B1%E4%BF%A1%E6%9C%8D.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="深信服笔试"/></a><div class="content"><a class="title" href="/2024/06/19/%E9%9D%A2%E7%BB%8F-%E6%B7%B1%E4%BF%A1%E6%9C%8D%E7%AC%94%E8%AF%95/" title="深信服笔试">深信服笔试</a><time datetime="2024-06-19T04:21:37.962Z" title="发表于 2024-06-19 12:21:37">2024-06-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/18/%E9%9D%A2%E7%BB%8F-%E5%B9%BF%E5%B7%9E%E5%AE%89%E9%9A%BD%E7%AC%94%E8%AF%95+%E9%9D%A2%E8%AF%95/" title="广州安隽笔试+面试"><img src="/./img/num3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="广州安隽笔试+面试"/></a><div class="content"><a class="title" href="/2024/06/18/%E9%9D%A2%E7%BB%8F-%E5%B9%BF%E5%B7%9E%E5%AE%89%E9%9A%BD%E7%AC%94%E8%AF%95+%E9%9D%A2%E8%AF%95/" title="广州安隽笔试+面试">广州安隽笔试+面试</a><time datetime="2024-06-18T09:18:48.456Z" title="发表于 2024-06-18 17:18:48">2024-06-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/18/%E9%9D%A2%E7%BB%8F-%E6%B5%B7%E9%B6%85%E7%A7%91%E6%8A%80%E9%9D%A2%E8%AF%95/" title="海鶅科技面试"><img src="/./img/num4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="海鶅科技面试"/></a><div class="content"><a class="title" href="/2024/06/18/%E9%9D%A2%E7%BB%8F-%E6%B5%B7%E9%B6%85%E7%A7%91%E6%8A%80%E9%9D%A2%E8%AF%95/" title="海鶅科技面试">海鶅科技面试</a><time datetime="2024-06-18T09:17:06.388Z" title="发表于 2024-06-18 17:17:06">2024-06-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/06/Project-%E5%B9%BF%E5%91%8A%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/" title="广告推荐系统"><img src="/../img/spikemall.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="广告推荐系统"/></a><div class="content"><a class="title" href="/2024/06/06/Project-%E5%B9%BF%E5%91%8A%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/" title="广告推荐系统">广告推荐系统</a><time datetime="2024-06-06T05:53:29.422Z" title="发表于 2024-06-06 13:53:29">2024-06-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/04/Work-%E4%BA%92%E8%B8%A2%E5%8A%9F%E8%83%BD/" title="互踢功能"><img src="/./img/num5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="互踢功能"/></a><div class="content"><a class="title" href="/2024/06/04/Work-%E4%BA%92%E8%B8%A2%E5%8A%9F%E8%83%BD/" title="互踢功能">互踢功能</a><time datetime="2024-06-04T07:28:35.971Z" title="发表于 2024-06-04 15:28:35">2024-06-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By PlanB</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://PlanBBBBB.github.io">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script async src="/js/title.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="0基础,学IT" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(./img/project.png);"> <a class="categoryBar-list-link" href="categories/Project/">Project</a><span class="categoryBar-list-count">6</span><span class="categoryBar-list-descr">Poject</span></li><li class="categoryBar-list-item" style="background:url(./img/study.png);"> <a class="categoryBar-list-link" href="categories/Study/">Study</a><span class="categoryBar-list-count">20</span><span class="categoryBar-list-descr">Study</span></li><li class="categoryBar-list-item" style="background:url(./img/面试.png);"> <a class="categoryBar-list-link" href="categories/Work/">Work</a><span class="categoryBar-list-count">5</span><span class="categoryBar-list-descr">面试</span></li><li class="categoryBar-list-item" style="background:url(./img/面经.png);"> <a class="categoryBar-list-link" href="categories/面经/">面经</a><span class="categoryBar-list-count">9</span><span class="categoryBar-list-descr">面经</span></li><li class="categoryBar-list-item" style="background:url(./img/work.png);"> <a class="categoryBar-list-link" href="categories/面试/">面试</a><span class="categoryBar-list-count">12</span><span class="categoryBar-list-descr">Work</span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__bounceInLeft');
    arr[i].setAttribute('data-wow-duration', '800ms');
    arr[i].setAttribute('data-wow-delay', '0ms');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__bounceInRight');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/08/27/Study-JVM/" alt=""><img width="48" height="48" src="../img/jvm.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-08-27</span><a class="blog-slider__title" href="2023/08/27/Study-JVM/" alt="">JVM</a><div class="blog-slider__text">JVM学习</div><a class="blog-slider__button" href="2023/08/27/Study-JVM/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/01/05/Study-MySQL高级部分学习/" alt=""><img width="48" height="48" src="../img/mysql.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-01-05</span><a class="blog-slider__title" href="2023/01/05/Study-MySQL高级部分学习/" alt="">MySQL高级部分学习</a><div class="blog-slider__text">用于学习MySQL后续的进阶部分</div><a class="blog-slider__button" href="2023/01/05/Study-MySQL高级部分学习/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/08/03/Study-Redis相关知识/" alt=""><img width="48" height="48" src="../img/redis.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-08-03</span><a class="blog-slider__title" href="2023/08/03/Study-Redis相关知识/" alt="">Redis相关知识</a><div class="blog-slider__text">用于学习Redis相关知识</div><a class="blog-slider__button" href="2023/08/03/Study-Redis相关知识/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/09/05/Study-Java集合/" alt=""><img width="48" height="48" src="../img/java集合.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" href="2023/09/05/Study-Java集合/" alt="">Java集合</a><div class="blog-slider__text">Java集合底层实现原理学习</div><a class="blog-slider__button" href="2023/09/05/Study-Java集合/" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><!-- hexo injector body_end end --></body></html>