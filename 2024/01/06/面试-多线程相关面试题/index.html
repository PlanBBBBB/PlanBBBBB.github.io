<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>多线程相关面试题 | PlanB's Blog</title><meta name="author" content="PlanB,2741718884@qq.com"><meta name="copyright" content="PlanB"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="多线程相关面试题">
<meta property="og:type" content="article">
<meta property="og:title" content="多线程相关面试题">
<meta property="og:url" content="https://planbbbbb.github.io/2024/01/06/%E9%9D%A2%E8%AF%95-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="PlanB&#39;s Blog">
<meta property="og:description" content="多线程相关面试题">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://planbbbbb.github.io/img/%E5%A4%9A%E7%BA%BF%E7%A8%8B.png">
<meta property="article:published_time" content="2024-01-06T09:59:53.226Z">
<meta property="article:modified_time" content="2024-06-14T02:47:04.477Z">
<meta property="article:author" content="PlanB">
<meta property="article:tag" content="并发编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://planbbbbb.github.io/img/%E5%A4%9A%E7%BA%BF%E7%A8%8B.png"><link rel="shortcut icon" href="/./img/%E9%A5%AE%E6%96%99.png"><link rel="canonical" href="https://planbbbbb.github.io/2024/01/06/%E9%9D%A2%E8%AF%95-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '多线程相关面试题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-14 10:47:04'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/%E5%A4%B4%E5%83%8F.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">61</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/../img/%E5%A4%9A%E7%BA%BF%E7%A8%8B.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">PlanB's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">多线程相关面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-06T09:59:53.226Z" title="发表于 2024-01-06 17:59:53">2024-01-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-14T02:47:04.477Z" title="更新于 2024-06-14 10:47:04">2024-06-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="多线程相关面试题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本篇文章取自黑马程序员，仅供学习使用</p>
<h1 id="Java多线程相关面试题"><a href="#Java多线程相关面试题" class="headerlink" title="Java多线程相关面试题"></a>Java多线程相关面试题</h1><h2 id="1-线程的基础知识"><a href="#1-线程的基础知识" class="headerlink" title="1.线程的基础知识"></a>1.线程的基础知识</h2><h3 id="1-1-线程和进程的区别？"><a href="#1-1-线程和进程的区别？" class="headerlink" title="1.1 线程和进程的区别？"></a>1.1 线程和进程的区别？</h3><blockquote>
<p>难易程度：☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的。</p>
<p><strong>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。</strong></p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221026105350827.png" alt="image-20221026105350827"></p>
<p>一个进程之内可以分为一到多个线程。</p>
<p>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行</p>
<p>Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。在 windows 中进程是不活动的，只是作为线程的容器</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221026105442158.png" alt="image-20221026105442158"></p>
<p><strong>二者对比</strong></p>
<ul>
<li><mark>进程是正在运行程序的实例，进程中包含了线程，每个线程执行不同的任务</mark></li>
<li><mark>不同的进程使用不同的内存空间，在当前进程下的所有线程可以共享内存空间</mark></li>
<li><mark>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低(上下文切换指的是从一个线程切换到另一个线程)</mark></li>
</ul>
<h3 id="1-2-并行和并发有什么区别？"><a href="#1-2-并行和并发有什么区别？" class="headerlink" title="1.2 并行和并发有什么区别？"></a>1.2 并行和并发有什么区别？</h3><blockquote>
<p>难易程度：☆</p>
<p>出现频率：☆</p>
</blockquote>
<p>单核CPU</p>
<ul>
<li><p>单核CPU下线程实际还是串行执行的</p>
</li>
<li><p>操作系统中有一个组件叫做任务调度器，将cpu的时间片（windows下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于cpu在线程间（时间片很短）的切换非常快，人类感觉是同时运行的 。</p>
</li>
<li><p>总结为一句话就是： 微观串行，宏观并行</p>
</li>
</ul>
<p>一般会将这种线程轮流使用CPU的做法称为并发（concurrent）</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230503203246348.png" alt="image-20230503203246348"></p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221026105607248.png" alt="image-20221026105607248"></p>
<p>多核CPU</p>
<p>每个核（core）都可以调度运行线程，这时候线程可以是并行的。</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230503203330700.png" alt="image-20230503203330700"></p>
<p><mark><strong>并发（concurrent）是同一时间应对（dealing with）多件事情的能力</strong></mark></p>
<p><mark><strong>并行（parallel）是同一时间动手做（doing）多件事情的能力</strong></mark></p>
<blockquote>
<p>举例：</p>
<ul>
<li><p>家庭主妇做饭、打扫卫生、给孩子喂奶，她一个人轮流交替做这多件事，这时就是并发</p>
</li>
<li><p>家庭主妇雇了个保姆，她们一起这些事，这时既有并发，也有并行（这时会产生竞争，例如锅只有一口，一个人用锅时，另一个人就得等待）</p>
</li>
<li><p>雇了3个保姆，一个专做饭、一个专打扫卫生、一个专喂奶，互不干扰，这时是并行</p>
</li>
</ul>
</blockquote>
<h3 id="1-3-创建线程的四种方式"><a href="#1-3-创建线程的四种方式" class="headerlink" title="1.3 创建线程的四种方式"></a>1.3 创建线程的四种方式</h3><blockquote>
<p>难易程度：☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<p>参考回答：</p>
<p>共有四种方式可以创建线程，分别是：继承Thread类、实现runnable接口、实现Callable接口、线程池创建线程</p>
<p>详细创建方式参考下面代码：</p>
<p>① <strong>继承Thread类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyThread...run...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建MyThread对象</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>() ;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>() ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用start方法启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>② <strong>实现runnable接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyRunnable...run...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建MyRunnable对象</span></span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">mr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>() ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建Thread对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mr) ;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mr) ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用start方法启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③ <strong>实现Callable接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyCallable...call...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建MyCallable对象</span></span><br><span class="line">        <span class="type">MyCallable</span> <span class="variable">mc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>() ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建F</span></span><br><span class="line">        FutureTask&lt;String&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;String&gt;(mc) ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建Thread对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ft) ;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ft) ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用start方法启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用ft的get方法获取执行结果</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> ft.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>④ <strong>线程池创建线程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyExecutors</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyRunnable...run...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程池对象</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> <span class="title class_">MyExecutors</span>()) ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-runnable-和-callable-有什么区别"><a href="#1-4-runnable-和-callable-有什么区别" class="headerlink" title="1.4 runnable 和 callable 有什么区别"></a>1.4 runnable 和 callable 有什么区别</h3><blockquote>
<p>难易程度：☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p>参考回答：</p>
<ol>
<li>Runnable 接口run方法<mark>没有返回值</mark>；Callable接口call方法<mark>有返回值</mark>，是个泛型，和Future、FutureTask配合可以用来<mark>获取异步执行的结果</mark></li>
<li>Callalbe接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。</li>
<li>Callable接口的call()方法<mark>允许抛出异常</mark>；而Runnable接口的run()方法的<mark>异常只能在内部消化</mark>，不能继续上抛</li>
</ol>
<h3 id="1-5-线程的-run-和-start-有什么区别？"><a href="#1-5-线程的-run-和-start-有什么区别？" class="headerlink" title="1.5 线程的 run()和 start()有什么区别？"></a>1.5 线程的 run()和 start()有什么区别？</h3><blockquote>
<p>难易程度：☆☆</p>
<p>出现频率：☆☆</p>
</blockquote>
<p>start(): <mark>用来启动线程</mark>，通过该线程调用run方法执行run方法中所定义的逻辑代码。<mark>start方法只能被调用一次</mark>。</p>
<p>run(): 封装了要被线程执行的代码，<mark>可以被调用多次</mark>。</p>
<h3 id="1-6-线程包括哪些状态，状态之间是如何变化的"><a href="#1-6-线程包括哪些状态，状态之间是如何变化的" class="headerlink" title="1.6 线程包括哪些状态，状态之间是如何变化的"></a>1.6 线程包括哪些状态，状态之间是如何变化的</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<p>线程的状态可以参考JDK中的Thread类中的枚举State</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 尚未启动的线程的线程状态</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        NEW,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 可运行线程的线程状态。处于可运行状态的线程正在 Java 虚拟机中执行，但它可能正在等待来自		 * 操作系统的其他资源，例如处理器。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        RUNNABLE,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 线程阻塞等待监视器锁的线程状态。处于阻塞状态的线程正在等待监视器锁进入同步块/方法或在调          * 用Object.wait后重新进入同步块/方法。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        BLOCKED,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 等待线程的线程状态。由于调用以下方法之一，线程处于等待状态：</span></span><br><span class="line"><span class="comment">		* Object.wait没有超时</span></span><br><span class="line"><span class="comment">         * 没有超时的Thread.join</span></span><br><span class="line"><span class="comment">         * LockSupport.park</span></span><br><span class="line"><span class="comment">         * 处于等待状态的线程正在等待另一个线程执行特定操作。</span></span><br><span class="line"><span class="comment">         * 例如，一个对对象调用Object.wait()的线程正在等待另一个线程对该对象调用Object.notify()			* 或Object.notifyAll() 。已调用Thread.join()的线程正在等待指定线程终止。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        WAITING,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 具有指定等待时间的等待线程的线程状态。由于以指定的正等待时间调用以下方法之一，线程处于定          * 时等待状态：</span></span><br><span class="line"><span class="comment">		* Thread.sleep</span></span><br><span class="line"><span class="comment">		* Object.wait超时</span></span><br><span class="line"><span class="comment">		* Thread.join超时</span></span><br><span class="line"><span class="comment">		* LockSupport.parkNanos</span></span><br><span class="line"><span class="comment">		* LockSupport.parkUntil</span></span><br><span class="line"><span class="comment">         * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 已终止线程的线程状态。线程已完成执行</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        TERMINATED;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>状态之间是如何变化的</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230503203629212.png" alt="image-20230503203629212"></p>
<p>分别是</p>
<ul>
<li><mark>新建</mark><ul>
<li>当一个线程对象被创建，但还未调用 start 方法时处于<strong>新建</strong>状态</li>
<li>此时未与操作系统底层线程关联</li>
</ul>
</li>
<li><mark>可运行</mark><ul>
<li>调用了 start 方法，就会由<strong>新建</strong>进入<strong>可运行</strong></li>
<li>此时与底层线程关联，由操作系统调度执行</li>
</ul>
</li>
<li><mark>终结</mark><ul>
<li>线程内代码已经执行完毕，由<strong>可运行</strong>进入<strong>终结</strong></li>
<li>此时会取消与底层线程关联</li>
</ul>
</li>
<li><mark>阻塞</mark><ul>
<li>当<mark>获取锁失败后</mark>，由<strong>可运行</strong>进入 Monitor 的阻塞队列<strong>阻塞</strong>，此时不占用 cpu 时间</li>
<li>当持锁线程释放锁时，会按照一定规则唤醒阻塞队列中的<strong>阻塞</strong>线程，唤醒后的线程进入<strong>可运行</strong>状态</li>
</ul>
</li>
<li><mark>等待</mark><ul>
<li>当<mark>获取锁成功后，但由于条件不满足</mark>，调用了 wait() 方法，此时从<strong>可运行</strong>状态释放锁进入 Monitor 等待集合<strong>等待</strong>，同样不占用 cpu 时间</li>
<li>当其它持锁线程调用 notify() 或 notifyAll() 方法，会按照一定规则唤醒等待集合中的<strong>等待</strong>线程，恢复为<strong>可运行</strong>状态</li>
</ul>
</li>
<li><mark>有时限等待</mark><ul>
<li>当获取锁成功后，但由于条件不满足，调用了 wait(long) 方法，此时从<strong>可运行</strong>状态释放锁进入 Monitor 等待集合进行<strong>有时限等待</strong>，同样不占用 cpu 时间</li>
<li>当其它持锁线程调用 notify() 或 notifyAll() 方法，会按照一定规则唤醒等待集合中的<strong>有时限等待</strong>线程，恢复为<strong>可运行</strong>状态，并重新去竞争锁</li>
<li>如果等待超时，也会从<strong>有时限等待</strong>状态恢复为<strong>可运行</strong>状态，并重新去竞争锁</li>
<li>还有一种情况是调用 sleep(long) 方法也会从<strong>可运行</strong>状态进入<strong>有时限等待</strong>状态，但与 Monitor 无关，不需要主动唤醒，超时时间到自然恢复为<strong>可运行</strong>状态</li>
</ul>
</li>
</ul>
<h3 id="1-7-新建-T1、T2、T3-三个线程，如何保证它们按顺序执行？"><a href="#1-7-新建-T1、T2、T3-三个线程，如何保证它们按顺序执行？" class="headerlink" title="1.7 新建 T1、T2、T3 三个线程，如何保证它们按顺序执行？"></a>1.7 新建 T1、T2、T3 三个线程，如何保证它们按顺序执行？</h3><blockquote>
<p>难易程度：☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p>在多线程中有多种方法让线程按特定顺序执行，你可以用线程类的<strong>join</strong>()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。</p>
<p>代码举例：</p>
<p>为了确保三个线程的顺序你应该先启动最后一个(T3调用T2，T2调用T1)，这样T1就会先完成而T3最后完成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoinTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        &#125;) ;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t1.join();                          <span class="comment">// 加入线程t1,只有t1线程执行完毕以后，再次执行该线程</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        &#125;) ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t2.join();                              <span class="comment">// 加入线程t2,只有t2线程执行完毕以后，再次执行该线程</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;t3&quot;</span>);</span><br><span class="line">        &#125;) ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-8-notify-和-notifyAll-有什么区别？"><a href="#1-8-notify-和-notifyAll-有什么区别？" class="headerlink" title="1.8 notify()和 notifyAll()有什么区别？"></a>1.8 notify()和 notifyAll()有什么区别？</h3><blockquote>
<p>难易程度：☆☆</p>
<p>出现频率：☆☆</p>
</blockquote>
<p><mark>notifyAll：唤醒所有wait的线程</mark></p>
<p><mark>notify：只随机唤醒一个 wait 线程</mark></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.basic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitNotify</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                <span class="keyword">while</span> (!flag)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;...wating...&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;...flag is true&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                <span class="keyword">while</span> (!flag)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;...wating...&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;...flag is true&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; hold lock&quot;</span>);</span><br><span class="line">                lock.notifyAll();</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-9-在-java-中-wait-和-sleep-方法的不同？"><a href="#1-9-在-java-中-wait-和-sleep-方法的不同？" class="headerlink" title="1.9 在 java 中 wait 和 sleep 方法的不同？"></a>1.9 在 java 中 wait 和 sleep 方法的不同？</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p>参考回答：</p>
<p>共同点</p>
<ul>
<li>wait() ，wait(long) 和 sleep(long) 的效果<mark>都是让当前线程暂时放弃 CPU 的使用权，进入阻塞状态</mark></li>
</ul>
<p>不同点</p>
<ul>
<li><p>方法归属不同</p>
<ul>
<li>sleep(long) 是 Thread 的静态方法</li>
<li>而 wait()，wait(long) 都是 Object 的成员方法，每个对象都有</li>
</ul>
</li>
<li><p>醒来时机不同</p>
<ul>
<li>执行 sleep(long) 和 wait(long) 的线程都会在等待相应毫秒后醒来</li>
<li><mark>wait(long) 和 wait() 还可以被 notify 唤醒</mark>，wait() 如果不唤醒就一直等下去</li>
<li>它们都可以被打断唤醒</li>
</ul>
</li>
<li><p>锁特性不同（重点）</p>
<ul>
<li><mark>wait 方法的调用必须先获取 wait 对象的锁，而 sleep 则无此限制</mark></li>
<li><mark>wait 方法执行后会释放对象锁，允许其它线程获得该对象锁（我放弃 cpu，但你们还可以用）</mark></li>
<li><mark>而 sleep 如果在 synchronized 代码块中执行，并不会释放对象锁（我放弃 cpu，你们也用不了）</mark></li>
</ul>
</li>
</ul>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitSleepCase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        sleeping();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">illegalWait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        LOCK.wait();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">waiting</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    get(<span class="string">&quot;t&quot;</span>).debug(<span class="string">&quot;waiting...&quot;</span>);</span><br><span class="line">                    LOCK.wait(<span class="number">5000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    get(<span class="string">&quot;t&quot;</span>).debug(<span class="string">&quot;interrupted...&quot;</span>);</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">            main.debug(<span class="string">&quot;other...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleeping</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    get(<span class="string">&quot;t&quot;</span>).debug(<span class="string">&quot;sleeping...&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">5000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    get(<span class="string">&quot;t&quot;</span>).debug(<span class="string">&quot;interrupted...&quot;</span>);</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">            main.debug(<span class="string">&quot;other...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-10-如何停止一个正在运行的线程？"><a href="#1-10-如何停止一个正在运行的线程？" class="headerlink" title="1.10 如何停止一个正在运行的线程？"></a>1.10 如何停止一个正在运行的线程？</h3><blockquote>
<p>难易程度：☆☆</p>
<p>出现频率：☆☆</p>
</blockquote>
<p>参考回答：</p>
<p>有三种方式可以停止线程</p>
<ul>
<li>使用退出标志，使线程正常退出，也就是当run方法完成后线程终止</li>
<li>使用stop方法强行终止（不推荐，方法已作废）</li>
<li><mark>使用interrupt方法中断线程</mark></li>
</ul>
<p>代码参考如下：</p>
<p>① <strong>使用退出标志，使线程正常退出</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterrupt1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span> ;     <span class="comment">// 线程执行的退出标记</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(!flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyThread...run...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建MyThread对象</span></span><br><span class="line">        <span class="type">MyInterrupt1</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInterrupt1</span>() ;</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程休眠6秒</span></span><br><span class="line">        Thread.sleep(<span class="number">6000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更改标记为true</span></span><br><span class="line">        t1.flag = <span class="literal">true</span> ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>② <strong>使用stop方法强行终止</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterrupt2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span> ;     <span class="comment">// 线程执行的退出标记</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(!flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyThread...run...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建MyThread对象</span></span><br><span class="line">        <span class="type">MyInterrupt2</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInterrupt2</span>() ;</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程休眠2秒</span></span><br><span class="line">        Thread.sleep(<span class="number">6000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用stop方法</span></span><br><span class="line">        t1.stop();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③ <strong>使用interrupt方法中断线程</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.basic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterrupt3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.打断阻塞的线程</span></span><br><span class="line">        <span class="comment">/*Thread t1 = new Thread(()-&gt;&#123;</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;t1 正在运行...&quot;);</span></span><br><span class="line"><span class="comment">            try &#123;</span></span><br><span class="line"><span class="comment">                Thread.sleep(5000);</span></span><br><span class="line"><span class="comment">            &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">                e.printStackTrace();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;, &quot;t1&quot;);</span></span><br><span class="line"><span class="comment">        t1.start();</span></span><br><span class="line"><span class="comment">        Thread.sleep(500);</span></span><br><span class="line"><span class="comment">        t1.interrupt();</span></span><br><span class="line"><span class="comment">        System.out.println(t1.isInterrupted());*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.打断正常的线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> current.isInterrupted();</span><br><span class="line">                <span class="keyword">if</span>(interrupted) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;打断状态：&quot;</span>+interrupted);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line"><span class="comment">//        t2.interrupt();</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-线程中并发锁"><a href="#2-线程中并发锁" class="headerlink" title="2.线程中并发锁"></a>2.线程中并发锁</h2><h3 id="2-1-讲一下synchronized关键字的底层原理？"><a href="#2-1-讲一下synchronized关键字的底层原理？" class="headerlink" title="2.1 讲一下synchronized关键字的底层原理？"></a>2.1 讲一下synchronized关键字的底层原理？</h3><blockquote>
<p>难易程度：☆☆☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<h4 id="2-1-1-基本使用"><a href="#2-1-1-基本使用" class="headerlink" title="2.1.1 基本使用"></a>2.1.1 基本使用</h4><p>如下抢票的代码，如果不加锁，就会出现超卖或者一张票卖给多个人</p>
<p>Synchronized【对象锁】采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TicketDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">ticketNum</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">getTicket</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ticketNum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;抢到一张票,剩余:&quot;</span> + ticketNum);</span><br><span class="line">            <span class="comment">// 非原子性操作</span></span><br><span class="line">            ticketNum--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TicketDemo</span> <span class="variable">ticketDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TicketDemo</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                ticketDemo.getTicket();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-2-Monitor"><a href="#2-1-2-Monitor" class="headerlink" title="2.1.2 Monitor"></a>2.1.2 Monitor</h4><p>Monitor 被翻译为监视器，是由jvm提供，c++语言实现</p>
<p>在代码中想要体现monitor需要借助javap命令查看clsss的字节码，比如以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>找到这个类的class文件，在class文件目录下执行<code>javap -v SyncTest.class</code>，反编译效果如下：</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230504165342501.png" alt="image-20230504165342501"></p>
<blockquote>
<ul>
<li>monitorenter    上锁开始的地方</li>
<li>monitorexit        解锁的地方</li>
<li>其中被monitorenter和monitorexit包围住的指令就是上锁的代码</li>
<li>有两个monitorexit的原因，第二个monitorexit是为了防止锁住的代码抛异常后不能及时释放锁</li>
</ul>
</blockquote>
<p>在使用了synchornized代码块时需要指定一个对象，所以synchornized也被称为对象锁</p>
<p>monitor主要就是跟这个对象产生关联，如下图</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230504165833809.png" alt="image-20230504165833809"></p>
<p>Monitor内部具体的存储结构：</p>
<ul>
<li><p>Owner：存储当前获取锁的线程的，只能有一个线程可以获取</p>
</li>
<li><p>EntryList：关联没有抢到锁的线程，处于Blocked状态的线程</p>
</li>
<li><p>WaitSet：关联调用了wait方法的线程，处于Waiting状态的线程</p>
</li>
</ul>
<p>具体的流程：</p>
<ul>
<li>代码进入synchorized代码块，先让lock（对象锁）关联的monitor，然后判断Owner是否有线程持有</li>
<li>如果没有线程持有，则让当前线程持有，表示该线程获取锁成功</li>
<li>如果有线程持有，则让当前线程进入entryList进行阻塞，如果Owner持有的线程已经释放了锁，在EntryList中的线程去竞争锁的持有权（非公平）</li>
<li>如果代码块中调用了wait()方法，则会进去WaitSet中进行等待</li>
</ul>
<p>🔴🟡🟢参考回答：</p>
<ul>
<li><p>Synchronized【对象锁】采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】</p>
</li>
<li><p>它的底层由monitor实现的，monitor是jvm级别的对象（ C++实现），线程获得锁需要使用对象（锁）关联monitor</p>
</li>
<li><p>在monitor内部有三个属性，分别是owner、entrylist、waitset</p>
</li>
<li><p><mark>其中owner是关联的获得锁的线程，并且只能关联一个线程；entrylist关联的是处于阻塞状态的线程；waitset关联的是处于Waiting状态的线程</mark></p>
</li>
</ul>
<h3 id="2-2-synchronized关键字的底层原理-进阶"><a href="#2-2-synchronized关键字的底层原理-进阶" class="headerlink" title="2.2 synchronized关键字的底层原理-进阶"></a>2.2 synchronized关键字的底层原理-进阶</h3><p>Monitor实现的锁属于重量级锁，你了解过锁升级吗？</p>
<ul>
<li><p>Monitor实现的锁属于重量级锁，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高，性能比较低。</p>
</li>
<li><p>在JDK 1.6引入了两种新型锁机制：偏向锁和轻量级锁，它们的引入是为了解决在没有多线程竞争或基本没有竞争的场景下因使用传统锁机制带来的性能开销问题。</p>
</li>
</ul>
<h4 id="2-2-1-对象的内存结构"><a href="#2-2-1-对象的内存结构" class="headerlink" title="2.2.1 对象的内存结构"></a>2.2.1 对象的内存结构</h4><p>在HotSpot虚拟机中，对象在内存中存储的布局可分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230504172253826.png" alt="image-20230504172253826"></p>
<p>我们需要重点分析MarkWord对象头</p>
<h4 id="2-2-2-MarkWord"><a href="#2-2-2-MarkWord" class="headerlink" title="2.2.2 MarkWord"></a>2.2.2 MarkWord</h4><p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230504172541922.png" alt="image-20230504172541922"></p>
<blockquote>
<ul>
<li><p>hashcode：25位的对象标识Hash码</p>
</li>
<li><p>age：对象分代年龄占4位</p>
</li>
<li><p>biased_lock：偏向锁标识，占1位 ，0表示没有开始偏向锁，1表示开启了偏向锁</p>
</li>
<li><p>thread：持有偏向锁的线程ID，占23位</p>
</li>
<li><p>epoch：偏向时间戳，占2位</p>
</li>
<li><p>ptr_to_lock_record：轻量级锁状态下，指向栈中锁记录的指针，占30位</p>
</li>
<li><p>ptr_to_heavyweight_monitor：重量级锁状态下，指向对象监视器Monitor的指针，占30位</p>
</li>
</ul>
</blockquote>
<p>我们可以通过lock的标识，来判断是哪一种锁的等级</p>
<ul>
<li>后三位是001表示无锁</li>
<li>后三位是101表示偏向锁</li>
<li>后两位是00表示轻量级锁</li>
<li>后两位是10表示重量级锁</li>
</ul>
<h4 id="2-2-3-再说Monitor重量级锁"><a href="#2-2-3-再说Monitor重量级锁" class="headerlink" title="2.2.3 再说Monitor重量级锁"></a>2.2.3 再说Monitor重量级锁</h4><p>每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，<strong>该对象头的Mark Word 中就被设置指向 Monitor 对象的指针</strong></p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230504172957271.png" alt="image-20230504172957271"></p>
<p>简单说就是：每个对象的对象头都可以设置monoitor的指针，让对象与monitor产生关联</p>
<h4 id="2-2-4-轻量级锁"><a href="#2-2-4-轻量级锁" class="headerlink" title="2.2.4 轻量级锁"></a>2.2.4 轻量级锁</h4><p>在很多的情况下，在Java程序运行时，同步块中的代码都是不存在竞争的，不同的线程交替的执行同步块中的代码。这种情况下，用重量级锁是没必要的。因此JVM引入了轻量级锁的概念。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// 同步块 A</span></span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// 同步块 B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>加锁的流程</strong></p>
<p>1.在线程栈中创建一个Lock Record，将其obj字段指向锁对象。</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230504173520412.png" alt="image-20230504173520412"></p>
<p>2.通过CAS指令将Lock Record的地址存储在对象头的mark word中（数据进行交换），如果对象处于无锁状态则修改成功，代表该线程获得了轻量级锁。</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230504173611219.png" alt="image-20230504173611219"></p>
<p>3.如果是当前线程已经持有该锁了，代表这是一次锁重入。设置Lock Record第一部分为null，起到了一个重入计数器的作用。</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230504173922343.png" alt="image-20230504173922343"></p>
<p>4.如果CAS修改失败，说明发生了竞争，需要膨胀为重量级锁。</p>
<p><strong>解锁过程</strong></p>
<p>1.遍历线程栈,找到所有obj字段等于当前锁对象的Lock Record。</p>
<p>2.如果Lock Record的Mark Word为null，代表这是一次重入，将obj设置为null后continue。</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230504173955680.png" alt="image-20230504173955680"></p>
<p>3.如果Lock Record的 Mark Word不为null，则利用CAS指令将对象头的mark word恢复成为无锁状态。如果失败则膨胀为重量级锁。</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230504174045458.png" alt="image-20230504174045458"></p>
<h4 id="2-2-5-偏向锁"><a href="#2-2-5-偏向锁" class="headerlink" title="2.2.5 偏向锁"></a>2.2.5 偏向锁</h4><p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。</p>
<p>Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现</p>
<p>这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// 同步块 A</span></span><br><span class="line">        m2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// 同步块 B</span></span><br><span class="line">        m3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>加锁的流程</strong></p>
<p>1.在线程栈中创建一个Lock Record，将其obj字段指向锁对象。</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230504174525256.png" alt="image-20230504174525256"></p>
<p>2.通过CAS指令将Lock Record的<strong>线程id</strong>存储在对象头的mark word中，同时也设置偏向锁的标识为101，如果对象处于无锁状态则修改成功，代表该线程获得了偏向锁。</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230504174505031.png" alt="image-20230504174505031"></p>
<p>3.如果是当前线程已经持有该锁了，代表这是一次锁重入。设置Lock Record第一部分为null，起到了一个重入计数器的作用。与轻量级锁不同的时，这里不会再次进行cas操作，只是判断对象头中的线程id是否是自己，因为缺少了cas操作，性能相对轻量级锁更好一些</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230504174736226.png" alt="image-20230504174736226"></p>
<p>解锁流程参考轻量级锁</p>
<h4 id="2-2-6-参考回答"><a href="#2-2-6-参考回答" class="headerlink" title="2.2.6 参考回答"></a>2.2.6 参考回答</h4><p>Java中的synchronized有偏向锁、轻量级锁、重量级锁三种形式，分别对应了锁只被一个线程持有、不同线程交替持有锁、多线程竞争锁三种情况。</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>重量级锁</td>
<td>底层使用的Monitor实现，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高，性能比较低。</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>线程加锁的时间是错开的（也就是没有竞争），可以使用轻量级锁来优化。轻量级修改了对象头的锁标志，相对重量级锁性能提升很多。每次修改都是CAS操作，保证原子性</td>
</tr>
<tr>
<td>偏向锁</td>
<td>一段很长的时间内都只被一个线程使用锁，可以使用了偏向锁，在第一次获得锁时，会有一个CAS操作，之后该线程再获取锁，只需要判断mark  word中是否是自己的线程id即可，而不是开销相对较大的CAS命令</td>
</tr>
</tbody></table>
<p><strong>一旦锁发生了竞争，都会升级为重量级锁</strong></p>
<h3 id="Sychronized和ReentrantLock区别"><a href="#Sychronized和ReentrantLock区别" class="headerlink" title="Sychronized和ReentrantLock区别"></a>Sychronized和ReentrantLock区别</h3><table>
<thead>
<tr>
<th>Sychronized</th>
<th>ReentrantLock</th>
</tr>
</thead>
<tbody><tr>
<td>Java中的一个关键字</td>
<td>JDK提供的一个类</td>
</tr>
<tr>
<td>JVM层面的锁</td>
<td>API层面的锁</td>
</tr>
<tr>
<td>自动加锁和释放锁</td>
<td>手动加锁和释放锁</td>
</tr>
<tr>
<td>不可获取当前线程是否上锁</td>
<td>可获取当前线程是否上锁isHeldByCurrentThread</td>
</tr>
<tr>
<td>非公平锁</td>
<td>非公平锁和公平锁，根据构造方法而定</td>
</tr>
<tr>
<td>不可中断</td>
<td>可以中断</td>
</tr>
<tr>
<td>锁的是对象，锁信息保存在对象头中底层有锁升级过程</td>
<td>int类型的state标识来标识锁的状态</td>
</tr>
<tr>
<td>底层有锁升级机制</td>
<td>没有锁升级机制</td>
</tr>
</tbody></table>
<h3 id="锁的状态升级总结"><a href="#锁的状态升级总结" class="headerlink" title="锁的状态升级总结"></a>锁的状态升级总结</h3><p>在 Java 中，锁有四种状态：无锁（Unlocked）、偏向锁（Biased Locking）、轻量级锁（Lightweight Locking）、重量级锁（Heavyweight Locking）。每种状态都有不同的性能特性和适用场景，锁的状态可以根据竞争情况进行升级。以下是对这四种锁状态的详细解释，包括它们的实现机制和状态升级的情况。</p>
<h4 id="1-无锁状态（Unlocked）"><a href="#1-无锁状态（Unlocked）" class="headerlink" title="1. 无锁状态（Unlocked）"></a>1. 无锁状态（Unlocked）</h4><h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><ul>
<li><strong>初始状态</strong>：所有对象默认处于无锁状态。</li>
<li><strong>效率最高</strong>：因为无锁状态下不存在锁的开销，线程可以直接访问对象。</li>
</ul>
<h5 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h5><ul>
<li><strong>Mark Word</strong>：Mark Word 中的锁标志位（最后两个位）为 01。</li>
</ul>
<h5 id="适用场景："><a href="#适用场景：" class="headerlink" title="适用场景："></a>适用场景：</h5><ul>
<li>对象不需要同步，所有线程都可以自由访问。</li>
</ul>
<h4 id="2-偏向锁（Biased-Locking）"><a href="#2-偏向锁（Biased-Locking）" class="headerlink" title="2. 偏向锁（Biased Locking）"></a>2. 偏向锁（Biased Locking）</h4><h5 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h5><ul>
<li><strong>偏向单个线程</strong>：如果一个线程第一次获取锁，锁会偏向于该线程，后续该线程再次请求锁时无需同步操作。</li>
<li><strong>低开销</strong>：偏向锁的获取和释放都非常快，没有 CAS（Compare-And-Swap）操作。</li>
</ul>
<h5 id="实现：-1"><a href="#实现：-1" class="headerlink" title="实现："></a>实现：</h5><ul>
<li><strong>Mark Word</strong>：Mark Word 中存储偏向线程的 ID 和锁标志位为 01。</li>
<li><strong>锁重偏向</strong>：当偏向线程再次进入同步块时，只需要检查对象头中的线程 ID 是否匹配即可。</li>
</ul>
<h5 id="升级情况："><a href="#升级情况：" class="headerlink" title="升级情况："></a>升级情况：</h5><ul>
<li><strong>锁撤销</strong>：如果另一个线程尝试获取该锁，偏向锁将被撤销，升级为轻量级锁。</li>
</ul>
<h5 id="适用场景：-1"><a href="#适用场景：-1" class="headerlink" title="适用场景："></a>适用场景：</h5><ul>
<li>同步块总是由同一个线程进入，没有竞争的情况。</li>
</ul>
<h4 id="3-轻量级锁（Lightweight-Locking）"><a href="#3-轻量级锁（Lightweight-Locking）" class="headerlink" title="3. 轻量级锁（Lightweight Locking）"></a>3. 轻量级锁（Lightweight Locking）</h4><h5 id="特点：-2"><a href="#特点：-2" class="headerlink" title="特点："></a>特点：</h5><ul>
<li><strong>竞争少</strong>：适用于少量竞争的场景。</li>
<li><strong>自旋等待</strong>：线程尝试获取锁时，如果锁已经被持有，将通过自旋（忙等待）来等待锁的释放，而不是直接阻塞。</li>
</ul>
<h5 id="实现：-2"><a href="#实现：-2" class="headerlink" title="实现："></a>实现：</h5><ul>
<li><strong>Mark Word</strong>：Mark Word 中的锁标志位为 00。</li>
<li><strong>锁记录</strong>：线程将对象头中的 Mark Word 复制到自己的栈帧中的锁记录（Lock Record）中，然后尝试使用 CAS 操作将对象头中的 Mark Word 替换为指向锁记录的指针。</li>
<li><strong>释放锁</strong>：锁释放时，会将锁记录中的内容恢复到对象头中。</li>
</ul>
<h5 id="升级情况：-1"><a href="#升级情况：-1" class="headerlink" title="升级情况："></a>升级情况：</h5><ul>
<li><strong>膨胀为重量级锁</strong>：如果自旋一定次数后仍未获取到锁，轻量级锁会膨胀为重量级锁，线程会进入阻塞状态。</li>
</ul>
<h5 id="适用场景：-2"><a href="#适用场景：-2" class="headerlink" title="适用场景："></a>适用场景：</h5><ul>
<li>适用于竞争不激烈且同步块执行时间短的情况。</li>
</ul>
<h4 id="4-重量级锁（Heavyweight-Locking）"><a href="#4-重量级锁（Heavyweight-Locking）" class="headerlink" title="4. 重量级锁（Heavyweight Locking）"></a>4. 重量级锁（Heavyweight Locking）</h4><h5 id="特点：-3"><a href="#特点：-3" class="headerlink" title="特点："></a>特点：</h5><ul>
<li><strong>高竞争</strong>：适用于竞争激烈的场景。</li>
<li><strong>线程阻塞</strong>：线程无法获取锁时会进入阻塞状态。</li>
</ul>
<h5 id="实现：-3"><a href="#实现：-3" class="headerlink" title="实现："></a>实现：</h5><ul>
<li><strong>Mark Word</strong>：Mark Word 中的锁标志位为 10。</li>
<li><strong>监视器（Monitor）</strong>：线程获取锁失败时，会被加入到等待队列（_EntryList）中，进入阻塞状态。</li>
</ul>
<h5 id="升级情况：-2"><a href="#升级情况：-2" class="headerlink" title="升级情况："></a>升级情况：</h5><ul>
<li><strong>无降级</strong>：重量级锁一旦形成，不会降级回轻量级锁或偏向锁。</li>
</ul>
<h5 id="适用场景：-3"><a href="#适用场景：-3" class="headerlink" title="适用场景："></a>适用场景：</h5><ul>
<li>适用于高竞争、长时间占用锁的场景。</li>
</ul>
<h4 id="锁的状态转换流程"><a href="#锁的状态转换流程" class="headerlink" title="锁的状态转换流程"></a>锁的状态转换流程</h4><ol>
<li><strong>无锁到偏向锁</strong>：当一个线程首次获取对象锁时，锁会偏向该线程。</li>
<li><strong>偏向锁到轻量级锁</strong>：当另一个线程尝试获取偏向锁时，偏向锁会被撤销，所有持有偏向锁的线程会重新竞争轻量级锁。</li>
<li><strong>轻量级锁到重量级锁</strong>：如果轻量级锁竞争激烈，自旋等待未成功时，轻量级锁会膨胀为重量级锁，线程进入阻塞状态。</li>
<li><strong>重量级锁的释放</strong>：重量级锁释放后，如果有等待的线程，<code>JVM</code> 会唤醒等待队列中的线程来竞争锁。</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>锁的状态在无锁、偏向锁、轻量级锁和重量级锁之间的转换是根据线程竞争情况动态进行的，以平衡性能和资源占用。无竞争时采用偏向锁和轻量级锁，以减少同步开销；高竞争时采用重量级锁，以避免大量的自旋等待造成的 CPU 资源浪费。理解这些机制有助于优化多线程程序的性能。</p>
<h3 id="2-3你谈谈-JMM（Java-内存模型）"><a href="#2-3你谈谈-JMM（Java-内存模型）" class="headerlink" title="2.3你谈谈 JMM（Java 内存模型）"></a>2.3你谈谈 JMM（Java 内存模型）</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p>JMM(Java Memory Model)<mark>Java内存模型</mark>,是java虚拟机规范中所定义的一种内存模型。</p>
<p>Java内存模型(Java Memory Model)描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量存储到内存和从内存中读取变量这样的底层细节。</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230504181638237.png" alt="image-20230504181638237"></p>
<p>特点：</p>
<ol>
<li><p>所有的共享变量都存储于主内存(计算机的RAM)这里所说的变量指的是实例变量和类变量。不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。</p>
</li>
<li><p>每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。</p>
</li>
<li><p>线程对变量的所有的操作(读，写)都必须在工作内存中完成，而不能直接读写主内存中的变量，不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存完成。</p>
</li>
</ol>
<p>🔴🟡🟢总结：</p>
<ul>
<li>JMM(Java Memory Model)<mark>Java内存模型</mark>，定义了<mark>共享内存</mark>中<mark>多线程程序读写操作的行为规范</mark>，通过这些规则来规范对内存的读写操作从而保证指令的正确性。</li>
<li>JMM把内存分为两块，一块是私有线程的工作区域(<mark>工作内存</mark>)，一块是所有线程的共享区域(<mark>主内存</mark>)</li>
<li>线程跟线程之间是<mark>相互隔离</mark>，线程跟线程<mark>交互需要通过主内存</mark></li>
</ul>
<h3 id="2-4-CAS-你知道吗？"><a href="#2-4-CAS-你知道吗？" class="headerlink" title="2.4 CAS 你知道吗？"></a>2.4 CAS 你知道吗？</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆</p>
</blockquote>
<h4 id="2-4-1-概述及基本工作流程"><a href="#2-4-1-概述及基本工作流程" class="headerlink" title="2.4.1 概述及基本工作流程"></a>2.4.1 概述及基本工作流程</h4><p>CAS的全称是： Compare And Swap(比较再交换)，它体现的一种乐观锁的思想，在无锁情况下保证线程操作共享数据的原子性。</p>
<p>在JUC（ java.util.concurrent ）包下实现的很多类都用到了CAS操作</p>
<ul>
<li><p>AbstractQueuedSynchronizer（AQS框架）</p>
</li>
<li><p>AtomicXXX类</p>
</li>
</ul>
<p>例子：</p>
<p>我们还是基于刚才学习过的JMM内存模型进行说明</p>
<ul>
<li>线程1与线程2都从主内存中获取变量int a &#x3D; 100,同时放到各个线程的工作内存中</li>
</ul>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230504181947319.png" alt="image-20230504181947319"></p>
<blockquote>
<p>一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当旧的预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。如果CAS操作失败，通过自旋的方式等待并再次尝试，直到成功</p>
</blockquote>
<ul>
<li>线程1操作：V：int a &#x3D; 100，A：int a &#x3D; 100，B：修改后的值：int a &#x3D; 101 (a++)<ul>
<li>线程1拿A的值与主内存V的值进行比较，判断是否相等</li>
<li>如果相等，则把B的值101更新到主内存中</li>
</ul>
</li>
</ul>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230504182129820.png" alt="image-20230504182129820"></p>
<ul>
<li>线程2操作：V：int a &#x3D; 100，A：int a &#x3D; 100，B：修改后的值：int a &#x3D; 99(a–)<ul>
<li>线程2拿A的值与主内存V的值进行比较，判断是否相等(目前不相等，因为线程1已更新V的值99)</li>
<li>不相等，则线程2更新失败</li>
</ul>
</li>
</ul>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230504181827330.png" alt="image-20230504181827330"></p>
<ul>
<li><p>自旋锁操作</p>
<ul>
<li><p>因为没有加锁，所以线程不会陷入阻塞，效率较高</p>
</li>
<li><p>如果竞争激烈，重试频繁发生，效率会受影响</p>
</li>
</ul>
</li>
</ul>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230504182447552.png" alt="image-20230504182447552"></p>
<p>需要不断尝试获取共享内存V中最新的值，然后再在新的值的基础上进行更新操作，如果失败就继续尝试获取新的值，直到更新成功</p>
<h4 id="2-4-2-CAS-底层实现"><a href="#2-4-2-CAS-底层实现" class="headerlink" title="2.4.2 CAS 底层实现"></a>2.4.2 CAS 底层实现</h4><p>CAS 底层依赖于一个 Unsafe 类来直接调用操作系统底层的 CAS 指令</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230504182737931.png" alt="image-20230504182737931"></p>
<p>都是native修饰的方法，由系统提供的接口执行，并非java代码实现，一般的思路也都是自旋锁实现</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230504182838426.png" alt="image-20230504182838426"></p>
<p>在java中比较常见使用有很多，比如ReentrantLock和Atomic开头的线程安全类，都调用了Unsafe中的方法</p>
<ul>
<li>ReentrantLock中的一段CAS代码</li>
</ul>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230504182958703.png" alt="image-20230504182958703"></p>
<h4 id="2-4-3-乐观锁和悲观锁的区别"><a href="#2-4-3-乐观锁和悲观锁的区别" class="headerlink" title="2.4.3 乐观锁和悲观锁的区别"></a>2.4.3 乐观锁和悲观锁的区别</h4><ul>
<li><p>CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。</p>
</li>
<li><p>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</p>
</li>
</ul>
<p>🔴🟡🟢总结：</p>
<ul>
<li>CAS的全称是: Compare And Swap(比较再交换)它体现的一种乐观锁的思想<mark>在无锁状态下保证线程操作数据的原子性</mark>。</li>
<li>CAS使用到的地方很多: AQS框架、AtomicXXX类</li>
<li>在操作共享变量的时候使用的自旋锁，效率上更高一些（<mark>因为没有加锁所以效率高</mark>）</li>
<li>CAS的底层是调用的<mark>Unsafe</mark>类中的方法，都是操作系统提供的，其他语言实现</li>
<li>乐观锁和悲观锁的区别如上👆</li>
</ul>
<p>🔴🟡🟢补充：</p>
<p><strong>重量级锁、轻量级锁、和偏向性锁</strong>是Java中用于实现线程同步的不同锁状态，它们在性能和应用场景上有一些区别。以下是它们的基本概念和区别：</p>
<ol>
<li><p><strong>偏向性锁（Biased Locking）：</strong></p>
<ul>
<li><strong>概念：</strong> 偏向性锁是为了在无竞争的情况下提高性能而引入的。它假设在大多数情况下，锁总是由同一线程多次获得。</li>
<li><strong>工作原理：</strong> 当一个线程第一次访问一个同步块时，偏向性锁会记录该线程的ID，并将对象头的Mark Word 设置为偏向锁。以后该线程再次进入同步块时，不再进行竞争，直接获取锁，避免了重量级锁的竞争开销。</li>
<li><strong>适用场景：</strong> 主要适用于单线程或者只有一个线程频繁访问同步块的情况。</li>
</ul>
</li>
<li><p><strong>轻量级锁（Lightweight Locking）：</strong></p>
<ul>
<li><strong>概念：</strong> 轻量级锁是为了在有少量竞争的情况下提高性能。当多个线程同时访问一个同步块时，会使用轻量级锁来减小竞争的代价。</li>
<li><strong>工作原理：</strong> 当线程尝试获取轻量级锁时，会将对象头的Mark Word 复制到线程的栈帧中，并尝试用CAS（Compare And Swap）原子指令将对象头的Mark Word 替换为指向线程栈帧的指针。如果替换成功，线程就获得了轻量级锁；否则，转为重量级锁。</li>
<li><strong>适用场景：</strong> 适用于线程交替执行同步块的情况，竞争不激烈。</li>
</ul>
</li>
<li><p><strong>重量级锁（Heavyweight Locking）：</strong></p>
<ul>
<li><strong>概念：</strong> 重量级锁是一种传统的锁机制，在多线程竞争激烈的情况下使用，它会引入阻塞来确保只有一个线程能够进入临界区。</li>
<li><strong>工作原理：</strong> 当线程尝试获取重量级锁时，如果轻量级锁获取失败，会升级为重量级锁。此时，其他线程将被阻塞，只有拥有锁的线程可以执行同步块内的代码。</li>
<li><strong>适用场景：</strong> 适用于高度竞争的情况，多个线程频繁竞争同一个锁。</li>
</ul>
</li>
</ol>
<p>总的来说，偏向性锁适用于单线程场景，轻量级锁适用于低竞争场景，而重量级锁适用于高竞争场景。Java的锁机制在运行时会根据实际情况自动选择使用哪种锁状态，以平衡性能和竞争的开销。</p>
<hr>
<h3 id="2-5-请谈谈你对-volatile-的理解"><a href="#2-5-请谈谈你对-volatile-的理解" class="headerlink" title="2.5 请谈谈你对 volatile 的理解"></a>2.5 请谈谈你对 volatile 的理解</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>
<h4 id="2-5-1-保证线程间的可见性"><a href="#2-5-1-保证线程间的可见性" class="headerlink" title="2.5.1 保证线程间的可见性"></a>2.5.1 保证线程间的可见性</h4><p>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的,volatile关键字会强制将修改的值立即写入主存。</p>
<p>一个典型的例子：永不停止的循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.basic;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可见性例子</span></span><br><span class="line"><span class="comment">// -Xint</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForeverLoop</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">stop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            stop = <span class="literal">true</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;modify stop to true...&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        foo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;stopped... c:&quot;</span>+ i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当执行上述代码的时候，发现foo()方法中的循环是结束不了的，也就说读取不到共享变量的值结束循环。</p>
<p>主要是因为在JVM虚拟机中有一个JIT（即时编辑器）给代码做了优化。</p>
<blockquote>
<p>上述代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">&gt;i++;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>在很短的时间内，这个代码执行的次数太多了，当达到了一个阈值，JIT就会优化此代码，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">&gt;i++;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>当把代码优化成这样子以后，及时<code>stop</code>变量改变为了<code>false</code>也依然停止不了循环</p>
</blockquote>
<p>解决方案：</p>
<p>第一：</p>
<p>在程序运行的时候加入vm参数<code>-Xint</code>表示禁用即时编辑器，不推荐，得不偿失（其他程序还要使用）</p>
<p>第二：</p>
<p>在修饰<code>stop</code>变量的时候加上<code>volatile</code>,表示当前代码禁用了即时编辑器，问题就可以解决，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">stop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-2-禁止进行指令重排序"><a href="#2-5-2-禁止进行指令重排序" class="headerlink" title="2.5.2 禁止进行指令重排序"></a>2.5.2 禁止进行指令重排序</h4><p>用 volatile 修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230505082441116.png" alt="image-20230505082441116"></p>
<p>在去获取上面的结果的时候，有可能会出现4种情况</p>
<p>情况一：先执行actor2获取结果—&gt;0,0(正常)</p>
<p>情况二：先执行actor1中的第一行代码，然后执行actor2获取结果—&gt;0,1(正常)</p>
<p>情况三：先执行actor1中所有代码，然后执行actor2获取结果—&gt;1,1(正常)</p>
<p>情况四：先执行actor1中第二行代码，然后执行actor2获取结果—&gt;1,0(发生了指令重排序，影响结果)</p>
<p><strong>解决方案</strong></p>
<p>在变量上添加volatile，禁止指令重排序，则可以解决问题</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230505082835588.png" alt="image-20230505082835588"></p>
<p>屏障添加的示意图</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230505082923729.png" alt="image-20230505082923729"></p>
<ul>
<li>写操作加的屏障是阻止上方其它写操作越过屏障排到volatile变量写之下</li>
<li>读操作加的屏障是阻止下方其它读操作越过屏障排到volatile变量读之上</li>
</ul>
<p><strong>其他补充</strong></p>
<p>我们上面的解决方案是把volatile加在了int y这个变量上，我们能不能把它加在int x这个变量上呢？</p>
<p>下面代码使用volatile修饰了x变量</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230505083124159.png" alt="image-20230505083124159"></p>
<p>屏障添加的示意图</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230505083217904.png" alt="image-20230505083217904"></p>
<p>这样显然是不行的，主要是因为下面两个原则：</p>
<ul>
<li>写操作加的屏障是阻止上方其它写操作越过屏障排到volatile变量写之下</li>
<li>读操作加的屏障是阻止下方其它读操作越过屏障排到volatile变量读之上</li>
</ul>
<p><mark>所以，现在我们就可以总结一个volatile使用的小妙招：</mark></p>
<ul>
<li><mark>写变量让volatile修饰的变量的在代码最后位置</mark></li>
<li><mark>读变量让volatile修饰的变量的在代码最开始位置</mark></li>
</ul>
<p>🔴🟡🟢总结：</p>
<ol>
<li>保证线程间的可见性<br>用 volatile 修饰共享变量，能够防止编译器等优化发生（<strong>其实就是JVM的语法糖</strong>），让一个线程对共享变量的修改对另一个线程可见</li>
<li>禁止进行指令重排序<br>指令重排：用volatile 修饰共享变量会在读、写共享变量时加入不同的屏障阻止其他读写操作越过屏障，从而达到阻止重排序的效果</li>
</ol>
<h3 id="2-6-什么是AQS？"><a href="#2-6-什么是AQS？" class="headerlink" title="2.6 什么是AQS？"></a>2.6 什么是AQS？</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<h4 id="2-6-1-概述"><a href="#2-6-1-概述" class="headerlink" title="2.6.1 概述"></a>2.6.1 概述</h4><p>全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架，它是构建锁或者其他同步组件的基础框架</p>
<p>AQS与Synchronized的区别</p>
<table>
<thead>
<tr>
<th><strong>synchronized</strong></th>
<th><strong>AQS</strong></th>
</tr>
</thead>
<tbody><tr>
<td>关键字，c++ 语言实现</td>
<td>java  语言实现</td>
</tr>
<tr>
<td>悲观锁，自动释放锁</td>
<td>悲观锁，手动开启和关闭</td>
</tr>
<tr>
<td>锁竞争激烈都是重量级锁，性能差</td>
<td>锁竞争激烈的情况下，提供了多种解决方案</td>
</tr>
</tbody></table>
<p>AQS常见的实现类</p>
<ul>
<li><p>ReentrantLock      阻塞式锁</p>
</li>
<li><p>Semaphore        信号量</p>
</li>
<li><p>CountDownLatch   倒计时锁</p>
</li>
</ul>
<h4 id="2-6-2-工作机制"><a href="#2-6-2-工作机制" class="headerlink" title="2.6.2 工作机制"></a>2.6.2 工作机制</h4><ul>
<li>在AQS中维护了一个使用了volatile修饰的state属性来表示资源的状态，0表示无锁，1表示有锁</li>
<li>提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList</li>
<li>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet</li>
</ul>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230505083840046.png" alt="image-20230505083840046"></p>
<blockquote>
<ul>
<li>线程0来了以后，去尝试修改state属性，如果发现state属性是0，就修改state状态为1，表示线程0抢锁成功</li>
<li>线程1和线程2也会先尝试修改state属性，发现state的值已经是1了，有其他线程持有锁，它们都会到FIFO队列中进行等待，</li>
<li>FIFO是一个双向队列，head属性表示头结点，tail表示尾结点</li>
</ul>
</blockquote>
<p><strong>如果多个线程共同去抢这个资源是如何保证原子性的呢？</strong></p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230505084451193.png" alt="image-20230505084451193"></p>
<p>在去修改state状态的时候，使用的cas自旋锁来保证原子性，确保只能有一个线程修改成功，修改失败的线程将会进入FIFO队列中等待</p>
<p><strong>AQS是公平锁吗，还是非公平锁？</strong></p>
<ul>
<li><p>新的线程与队列中的线程共同来抢资源，是非公平锁</p>
</li>
<li><p>新的线程到队列中等待，只让队列中的head线程获取锁，是公平锁</p>
</li>
</ul>
<blockquote>
<p>比较典型的AQS实现类ReentrantLock，它默认就是非公平锁，新的线程与队列中的线程共同来抢资源</p>
</blockquote>
<p>🔴🟡🟢总结：</p>
<ul>
<li>AQS是多线程中的队列同步器。是一种<mark><strong>锁机制</strong></mark>，它是做为一个<mark>基础框架</mark>使用的像ReentrantLock、Semaphore都是基于AQS实现的</li>
<li>AQS内部维护了一个先进先出的双向队列，队列中存储的排队的线程</li>
<li>在AQS内部还有一个属性state，这个state就相当于是一个资源，默认是0(无锁状态)，如果队列中的有一个线程修改成功了state为1，则当前线程就相等于获取了资源</li>
<li>在对state修改的时候使用的cas操作，保证多个线程修改的情况下原子性</li>
</ul>
<h3 id="2-5-ReentrantLock的实现原理"><a href="#2-5-ReentrantLock的实现原理" class="headerlink" title="2.5 ReentrantLock的实现原理"></a>2.5 ReentrantLock的实现原理</h3><blockquote>
<p>难易程度：☆☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<h4 id="2-5-1-概述"><a href="#2-5-1-概述" class="headerlink" title="2.5.1 概述"></a>2.5.1 概述</h4><p>ReentrantLock翻译过来是可重入锁，相对于synchronized它具备以下特点：</p>
<ul>
<li><p>可中断</p>
</li>
<li><p>可以设置超时时间</p>
</li>
<li><p>可以设置公平锁</p>
</li>
<li><p>支持多个条件变量</p>
</li>
<li><p>与synchronized一样，都支持重入</p>
</li>
</ul>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230505091736569.png" alt="image-20230505091736569"></p>
<h4 id="2-5-2-实现原理"><a href="#2-5-2-实现原理" class="headerlink" title="2.5.2 实现原理"></a>2.5.2 实现原理</h4><p>ReentrantLock主要利用CAS+AQS队列来实现。它支持公平锁和非公平锁，两者的实现类似</p>
<p>构造方法接受一个可选的公平参数（默认非公平锁），当设置为true时，表示公平锁，否则为非公平锁。公平锁的效率往往没有非公平锁的效率高，在许多线程访问的情况下，公平锁表现出较低的吞吐量。</p>
<p>查看ReentrantLock源码中的构造方法：</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230505091827720.png" alt="image-20230505091827720"></p>
<p>提供了两个构造方法，不带参数的默认为非公平</p>
<p>如果使用带参数的构造函数，并且传的值为true，则是公平锁</p>
<p>其中NonfairSync和FairSync这两个类父类都是Sync</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230505092151244.png" alt="image-20230505092151244"></p>
<p>而Sync的父类是AQS，所以可以得出ReentrantLock底层主要实现就是基于AQS来实现的</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230505091833629.png" alt="image-20230505091833629"></p>
<p><strong>工作流程</strong></p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230505092340431.png" alt="image-20230505092340431"></p>
<ul>
<li><p>线程来抢锁后使用cas的方式修改state状态，修改状态成功为1，则让exclusiveOwnerThread属性指向当前线程，获取锁成功</p>
</li>
<li><p>假如修改状态失败，则会进入双向队列中等待，head指向双向队列头部，tail指向双向队列尾部</p>
</li>
<li><p>当exclusiveOwnerThread为null的时候，则会唤醒在双向队列中等待的线程</p>
</li>
<li><p>公平锁则体现在按照先后顺序获取锁，非公平体现在不在排队的线程也可以抢锁</p>
</li>
</ul>
<h3 id="2-6-synchronized和Lock有什么区别"><a href="#2-6-synchronized和Lock有什么区别" class="headerlink" title="2.6 synchronized和Lock有什么区别 ?"></a>2.6 synchronized和Lock有什么区别 ?</h3><blockquote>
<p>难易程度：☆☆☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<p>参考回答</p>
<ul>
<li>语法层面<ul>
<li>synchronized 是关键字，源码在 jvm 中，用 c++ 语言实现</li>
<li>Lock 是接口，源码由 jdk 提供，用 java 语言实现</li>
<li>使用 synchronized 时，退出同步代码块锁会<strong>自动释放</strong>，而使用 Lock 时，<strong>需要手动调用 unlock 方法释放锁</strong></li>
</ul>
</li>
<li>功能层面<ul>
<li>二者<strong>均属于悲观锁</strong>、都具备基本的互斥、同步、锁重入功能</li>
<li>Lock 提供了许多 synchronized 不具备的功能，例如<strong>获取等待状态、公平锁、可打断、可超时、多条件变量</strong></li>
<li>Lock 有适合不同场景的实现，如 ReentrantLock， ReentrantReadWriteLock</li>
</ul>
</li>
<li>性能层面<ul>
<li>在没有竞争时，synchronized 做了很多优化，如偏向锁、轻量级锁，性能不赖</li>
<li>在竞争激烈时，Lock 的实现通常会提供更好的性能</li>
</ul>
</li>
</ul>
<h3 id="2-7-死锁产生的条件是什么？"><a href="#2-7-死锁产生的条件是什么？" class="headerlink" title="2.7 死锁产生的条件是什么？"></a>2.7 死锁产生的条件是什么？</h3><blockquote>
<p>难易程度：☆☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p><strong>死锁</strong>：一个线程需要同时获取多把锁，这时就容易发生死锁</p>
<blockquote>
<p>例如：</p>
<p>t1 线程获得A对象锁，接下来想获取B对象的锁</p>
<p>t2 线程获得B对象锁，接下来想获取A对象的锁 </p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.basic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Thread.sleep;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Deadlock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">A</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">B</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;lock A&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;lock B&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;操作...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;lock B&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;lock A&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;操作...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台输出结果</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20220902171032898.png" alt="image-20220902171032898"></p>
<p>此时程序并没有结束，这种现象就是死锁现象…线程t1持有A的锁等待获取B锁，线程t2持有B的锁等待获取A的锁。</p>
<h3 id="2-8-如何进行死锁诊断？"><a href="#2-8-如何进行死锁诊断？" class="headerlink" title="2.8 如何进行死锁诊断？"></a>2.8 如何进行死锁诊断？</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p>当程序出现了死锁现象，我们可以使用jdk自带的工具：jps和 jstack</p>
<p>步骤如下：</p>
<p>第一：查看运行的线程</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20220902171426738.png" alt="image-20220902171426738"></p>
<p>第二：使用jstack查看线程运行的情况，下图是截图的关键信息</p>
<p>运行命令：<code>jstack -l 46032</code></p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20220902172229567.png" alt="image-20220902172229567"></p>
<p><strong>其他解决工具，可视化工具</strong></p>
<ul>
<li>jconsole</li>
</ul>
<p>用于对jvm的内存，线程，类 的监控，是一个基于 jmx 的 GUI 性能监控工具</p>
<p>打开方式：java 安装目录 bin目录下 直接启动 jconsole.exe 就行</p>
<ul>
<li>VisualVM：故障处理工具</li>
</ul>
<p>能够监控线程，内存情况，查看方法的CPU时间和内存中的对 象，已被GC的对象，反向查看分配的堆栈</p>
<p>打开方式：java 安装目录 bin目录下 直接启动 jvisualvm.exe就行</p>
<h3 id="2-10-ConcurrentHashMap"><a href="#2-10-ConcurrentHashMap" class="headerlink" title="2.10  ConcurrentHashMap"></a>2.10  ConcurrentHashMap</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<p>ConcurrentHashMap 是一种线程安全的高效Map集合</p>
<p>底层数据结构：</p>
<ul>
<li><p>JDK1.7底层采用分段的数组+链表实现</p>
</li>
<li><p>JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表&#x2F;红黑二叉树。</p>
</li>
</ul>
<h4 id="（1）-JDK1-7中concurrentHashMap"><a href="#（1）-JDK1-7中concurrentHashMap" class="headerlink" title="（1） JDK1.7中concurrentHashMap"></a>（1） JDK1.7中concurrentHashMap</h4><p>数据结构</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230505092654811.png" alt="image-20230505092654811"></p>
<blockquote>
<ul>
<li>提供了一个segment数组，在初始化ConcurrentHashMap 的时候可以指定数组的长度，默认是16，一旦初始化之后中间不可扩容</li>
<li>在每个segment中都可以挂一个HashEntry数组，数组里面可以存储具体的元素，HashEntry数组是可以扩容的</li>
<li>在HashEntry存储的数组中存储的元素，如果发生冲突，则可以挂单向链表</li>
</ul>
</blockquote>
<p>存储流程</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230505093055382.png" alt="image-20230505093055382"></p>
<ul>
<li>先去计算key的hash值，然后确定segment数组下标</li>
<li>再通过hash值确定hashEntry数组中的下标存储数据</li>
<li>在进行操作数据的之前，会先判断当前segment对应下标位置是否有线程进行操作，为了线程安全使用的是ReentrantLock进行加锁，如果获取锁是被会使用cas自旋锁进行尝试</li>
</ul>
<h4 id="（2）-JDK1-8中concurrentHashMap"><a href="#（2）-JDK1-8中concurrentHashMap" class="headerlink" title="（2） JDK1.8中concurrentHashMap"></a>（2） JDK1.8中concurrentHashMap</h4><p>在JDK1.8中，放弃了Segment臃肿的设计，数据结构跟HashMap的数据结构是一样的：数组+红黑树+链表</p>
<p>采用 CAS + Synchronized来保证并发安全进行实现</p>
<ul>
<li><p>CAS控制数组节点的添加</p>
</li>
<li><p>synchronized只锁定当前链表或红黑二叉树的首节点，只要hash不冲突，就不会产生并发的问题 , 效率得到提升</p>
</li>
</ul>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230505093507265.png" alt="image-20230505093507265"></p>
<p>🔴🟡🟢总结：</p>
<ol>
<li>底层数据结构:<br>JDK1.7底层采用分段的数组+链表实现<br>JDK18 采用的数据结构跟HashMap1.8的结构一样，数组+链表&#x2F;红黑二叉树</li>
<li>加锁的方式<br>JDK1.7采用Segment分段锁，底层使用的是ReentrantLock<br>JDK1.8采用CAS添加新节点，采用synchronized锁定链表或红黑二叉树的<mark>首节点</mark>，相对Segment分段锁粒度更细，性能更好</li>
</ol>
<h3 id="2-11-导致并发程序出现问题的根本原因是什么"><a href="#2-11-导致并发程序出现问题的根本原因是什么" class="headerlink" title="2.11 导致并发程序出现问题的根本原因是什么"></a>2.11 导致并发程序出现问题的根本原因是什么</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p>Java并发编程三大特性</p>
<ul>
<li><p>原子性</p>
</li>
<li><p>可见性</p>
</li>
<li><p>有序性</p>
</li>
</ul>
<h4 id="（1）原子性"><a href="#（1）原子性" class="headerlink" title="（1）原子性"></a>（1）原子性</h4><p>一个线程在CPU中操作不可暂停，也不可中断，要不执行完成，要不不执行</p>
<p>比如，如下代码能保证原子性吗？</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230505205200628.png" alt="image-20230505205200628"></p>
<p>以上代码会出现超卖或者是一张票卖给同一个人，执行并不是原子性的</p>
<p>解决方案：</p>
<p>1.synchronized：同步加锁</p>
<p>2.JUC里面的lock：加锁</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230505210853493.png" alt="image-20230505210853493"></p>
<h4 id="（2）内存可见性"><a href="#（2）内存可见性" class="headerlink" title="（2）内存可见性"></a>（2）内存可见性</h4><p>内存可见性：让一个线程对共享变量的修改对另一个线程可见</p>
<p>比如，以下代码不能保证内存可见性</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230505211002252.png" alt="image-20230505211002252"></p>
<p>解决方案：</p>
<ul>
<li><p>synchronized</p>
</li>
<li><p>volatile（推荐）</p>
</li>
<li><p>LOCK</p>
</li>
</ul>
<h4 id="（3）有序性"><a href="#（3）有序性" class="headerlink" title="（3）有序性"></a>（3）有序性</h4><p>指令重排：处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的</p>
<p>还是之前的例子，如下代码：</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230505211209336.png" alt="image-20230505211209336"></p>
<p>解决方案：</p>
<ul>
<li>volatile</li>
</ul>
<h2 id="3-线程池"><a href="#3-线程池" class="headerlink" title="3.线程池"></a>3.线程池</h2><p>参考文章：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903910096764942">https://juejin.cn/post/6844903910096764942</a></p>
<h3 id="3-1-说一下线程池的核心参数（线程池的执行原理知道嘛）"><a href="#3-1-说一下线程池的核心参数（线程池的执行原理知道嘛）" class="headerlink" title="3.1 说一下线程池的核心参数（线程池的执行原理知道嘛）"></a>3.1 说一下线程池的核心参数（线程池的执行原理知道嘛）</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<p>线程池核心参数主要参考ThreadPoolExecutor这个类的7个参数的构造函数</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230505220514872.png" alt="image-20230505220514872"></p>
<ul>
<li><p>corePoolSize 核心线程数目</p>
</li>
<li><p>maximumPoolSize 最大线程数目 &#x3D; (核心线程+救急线程的最大数目)</p>
</li>
<li><p>keepAliveTime 生存时间 - 救急线程的生存时间，生存时间内没有新任务，此线程资源会释放</p>
</li>
<li><p>unit 时间单位 - 救急线程的生存时间单位，如秒、毫秒等</p>
</li>
<li><p>workQueue - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务</p>
</li>
<li><p>threadFactory 线程工厂 - 可以定制线程对象的创建，例如设置线程名字、是否是守护线程等</p>
</li>
<li><p>handler 拒绝策略 - 当所有线程都在繁忙，workQueue 也放满时，会触发拒绝策略</p>
</li>
</ul>
<p><strong>工作流程</strong></p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230505220701835.png" alt="image-20230505220701835"></p>
<blockquote>
<p>1，任务在提交的时候，首先判断核心线程数是否已满，如果没有满则直接添加到工作线程执行</p>
<p>2，如果核心线程数满了，则判断阻塞队列是否已满，如果没有满，当前任务存入阻塞队列</p>
<p>3，如果阻塞队列也满了，则判断线程数是否小于最大线程数，如果满足条件，则使用临时线程执行任务</p>
<p>如果核心或临时线程执行完成任务后会检查阻塞队列中是否有需要执行的线程，如果有，则使用非核心线程执行任务</p>
<p>4，如果所有线程都在忙着（核心线程+临时线程），则走拒绝策略</p>
</blockquote>
<p>拒绝策略：</p>
<p>1.AbortPolicy：直接抛出异常，默认策略；</p>
<p>2.CallerRunsPolicy：用调用者所在的线程来执行任务；</p>
<p>3.DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</p>
<p>4.DiscardPolicy：直接丢弃任务；</p>
<h3 id="3-2-线程池中有哪些常见的阻塞队列"><a href="#3-2-线程池中有哪些常见的阻塞队列" class="headerlink" title="3.2 线程池中有哪些常见的阻塞队列"></a>3.2 线程池中有哪些常见的阻塞队列</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p>workQueue - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务</p>
<p>比较常见的有4个，用的最多是ArrayBlockingQueue和LinkedBlockingQueue</p>
<p>1.<mark><strong>ArrayBlockingQueue</strong></mark>：基于数组结构的有界阻塞队列，FIFO（先进先出）。</p>
<p>2.<mark><strong>LinkedBlockingQueue</strong></mark>：基于链表结构的有界阻塞队列，FIFO（先进先出）。</p>
<p>3.DelayedWorkQueue ：是一个优先级队列，它可以保证每次出队的任务都是当前队列中执行时间最靠前的</p>
<p>4.SynchronousQueue：不存储元素的阻塞队列，每个插入操作都必须等待一个移出操作。</p>
<p><strong>ArrayBlockingQueue的LinkedBlockingQueue区别</strong></p>
<table>
<thead>
<tr>
<th><strong>LinkedBlockingQueue</strong></th>
<th><strong>ArrayBlockingQueue</strong></th>
</tr>
</thead>
<tbody><tr>
<td>默认无界，支持有界</td>
<td>强制有界</td>
</tr>
<tr>
<td>底层是链表</td>
<td>底层是数组</td>
</tr>
<tr>
<td>是懒惰的，创建节点的时候添加数据</td>
<td>提前初始化 Node  数组</td>
</tr>
<tr>
<td>入队会生成新 Node</td>
<td>Node需要是提前创建好的</td>
</tr>
<tr>
<td><mark>两把锁（头尾）</mark></td>
<td><mark>一把锁</mark></td>
</tr>
</tbody></table>
<p>左边是LinkedBlockingQueue加锁的方式，右边是ArrayBlockingQueue加锁的方式</p>
<ul>
<li>LinkedBlockingQueue读和写各有一把锁，<mark>性能</mark>相对较好</li>
<li>ArrayBlockingQueue只有一把锁，读和写公用，性能相对于LinkedBlockingQueue差一些</li>
</ul>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230505221424359.png" alt="image-20230505221424359"></p>
<p>在阻塞队列中，读和写操作分别指的是从队列中取出元素和向队列中添加元素。具体来说：</p>
<ul>
<li><strong>读操作</strong>（也叫取操作或消费操作）：从队列的头部取出一个元素。</li>
<li><strong>写操作</strong>（也叫插入操作或生产操作）：向队列的尾部添加一个元素。</li>
</ul>
<p>对于 <code>LinkedBlockingQueue</code> 和 <code>ArrayBlockingQueue</code>，它们的实现方式对这些操作的锁机制有不同的影响，这会影响到它们在高并发环境下的性能。</p>
<h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><ul>
<li>读操作和写操作各有一把锁：<ul>
<li><code>LinkedBlockingQueue</code> 使用了两个独立的锁来管理读操作（取元素）和写操作（插入元素）。这样一来，读写操作可以并行进行，因为一个锁住插入操作，不会影响取出操作，反之亦然。</li>
<li>在高并发环境下，这种实现方式可以减少读写操作之间的竞争，从而提高性能。</li>
</ul>
</li>
</ul>
<h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><ul>
<li>读操作和写操作共用一把锁：<ul>
<li><code>ArrayBlockingQueue</code> 使用单一的锁来管理所有的读操作和写操作。这意味着当一个线程在执行插入操作时，其他线程不能进行取出操作，反之亦然。</li>
<li>由于读写操作不能并行进行，在高并发环境下，性能可能会受到影响，因为操作之间的锁竞争会导致更多的线程等待。</li>
</ul>
</li>
</ul>
<h4 id="性能影响"><a href="#性能影响" class="headerlink" title="性能影响"></a>性能影响</h4><ul>
<li><strong><code>LinkedBlockingQueue</code> 的性能优势</strong>：<ul>
<li>因为有两把锁，读操作和写操作可以并行进行，从而减少了锁竞争和线程等待时间。</li>
<li>适用于读写操作频繁且并发度较高的场景。</li>
</ul>
</li>
<li><strong><code>ArrayBlockingQueue</code> 的性能劣势</strong>：<ul>
<li>由于只有一把锁，所有的操作都必须串行化，从而增加了锁竞争和线程等待时间。</li>
<li>更适用于读写操作较少或者并发度不高的场景。</li>
</ul>
</li>
</ul>
<h3 id="3-3-如何确定核心线程数"><a href="#3-3-如何确定核心线程数" class="headerlink" title="3.3 如何确定核心线程数"></a>3.3 如何确定核心线程数</h3><blockquote>
<p>难易程度：☆☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p>总结：</p>
<p>取自：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903910096764942?searchId=20240523143106992E18EE943C881683A6#heading-5">https://juejin.cn/post/6844903910096764942?searchId=20240523143106992E18EE943C881683A6#heading-5</a></p>
<blockquote>
<p>我们知道任务一般有两种：CPU密集型和IO密集型。那么面对CPU密集型的任务，线程数不宜过多，一般选择CPU核心数+1或者核心数的2倍是比较合理的一个值。因此我们可以考虑将corePoolSize设置为CPU核心数+1，maxPoolSize设置为核心数的2倍。那么同样的，面对IO密集型任务时，我们可以考虑以核心数乘以4倍作为核心线程数，然后核心数乘以5倍作为最大线程数的方式去设置线程数，这样的设置会比直接拍脑袋设置一个值会更合理一些。</p>
<p>当然总的线程数不宜过多，控制在100个线程以内比较合理，否则线程数过多可能会导致频繁地上下文切换，导致系统性能反不如前。</p>
</blockquote>
<p>在设置核心线程数之前，需要先熟悉一些执行线程池执行任务的类型</p>
<ul>
<li>IO密集型任务</li>
</ul>
<p>一般来说：文件读写、DB读写、网络请求等</p>
<p>推荐：核心线程数大小设置为2N+1    （N为计算机的CPU核数）</p>
<ul>
<li>CPU密集型任务</li>
</ul>
<p>一般来说：计算型代码、Bitmap转换、Gson转换等</p>
<p>推荐：核心线程数大小设置为N+1    （N为计算机的CPU核数）</p>
<p>java代码查看CPU核数</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230505221837189.png" alt="image-20230505221837189"></p>
<p>🔴🟡🟢<strong>参考回答：</strong></p>
<p>① 高并发、任务执行时间短 –&gt;（ CPU核数+1 ），减少线程上下文的切换</p>
<p>② 并发不高、任务执行时间长</p>
<ul>
<li><p>IO密集型的任务 –&gt; (CPU核数 * 2 + 1)</p>
</li>
<li><p>计算密集型任务 –&gt; （ CPU核数+1 ）</p>
</li>
</ul>
<p>③ 并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（2）</p>
<h3 id="3-4-线程池的种类有哪些"><a href="#3-4-线程池的种类有哪些" class="headerlink" title="3.4 线程池的种类有哪些"></a>3.4 线程池的种类有哪些</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p>在java.util.concurrent.Executors类中提供了大量创建连接池的静态方法，常见就有四种</p>
<ol>
<li><p>创建使用固定线程数的线程池</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230505221959259.png" alt="image-20230505221959259"></p>
<ul>
<li><p>核心线程数与最大线程数一样，没有救急线程</p>
</li>
<li><p>阻塞队列是LinkedBlockingQueue，最大容量为Integer.MAX_VALUE</p>
</li>
<li><p><mark>适用场景：适用于任务量已知，相对耗时的任务</mark></p>
</li>
<li><p>案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FixedThreadPoolCase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">FixedThreadDemo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                System.out.println(name + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//创建一个固定大小的线程池，核心线程数和最大线程数都是3</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            executorService.submit(<span class="keyword">new</span> <span class="title class_">FixedThreadDemo</span>());</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>单线程化的线程池，它只会用唯一的工作线程来执行任 务，保证所有任务按照指定顺序(FIFO)执行</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230505222050294.png" alt="image-20230505222050294"></p>
<ul>
<li><p>核心线程数和最大线程数都是1</p>
</li>
<li><p>阻塞队列是LinkedBlockingQueue，最大容量为Integer.MAX_VALUE</p>
</li>
<li><p><mark>适用场景：适用于按照顺序执行的任务</mark></p>
</li>
<li><p>案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewSingleThreadCase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//单个线程池，核心线程数和最大线程数都是1</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> <span class="title class_">Demo</span>());</span><br><span class="line">            Thread.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>可缓存线程池</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230505222126391.png" alt="image-20230505222126391"></p>
<ul>
<li><p>核心线程数为0</p>
</li>
<li><p>最大线程数是Integer.MAX_VALUE</p>
</li>
<li><p>阻塞队列为SynchronousQueue:不存储元素的阻塞队列，每个插入操作都必须等待一个移出操作。</p>
</li>
<li><p><mark>适用场景：适合任务数比较密集，但每个任务执行时间较短的情况</mark></p>
</li>
<li><p>案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CachedThreadPoolCase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//修改睡眠时间，模拟线程执行需要花费的时间</span></span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">                System.out.println(name + <span class="string">&quot;执行完了&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//创建一个缓存的线程，没有核心线程数，最大线程数为Integer.MAX_VALUE</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> <span class="title class_">Demo</span>());</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>提供了“延迟”和“周期执行”功能的ThreadPoolExecutor。</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230505222203615.png" alt="image-20230505222203615"></p>
<ul>
<li><p><mark>适用场景：有定时和延迟执行的任务</mark></p>
</li>
<li><p>案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledThreadPoolCase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line"></span><br><span class="line">                System.out.println(name + <span class="string">&quot;, 开始：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(name + <span class="string">&quot;, 结束：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//按照周期执行的线程池，核心线程数为2，最大线程数为Integer.MAX_VALUE</span></span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">scheduledThreadPool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;程序开始：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * schedule 提交任务到线程池中</span></span><br><span class="line"><span class="comment">         * 第一个参数：提交的任务</span></span><br><span class="line"><span class="comment">         * 第二个参数：任务执行的延迟时间</span></span><br><span class="line"><span class="comment">         * 第三个参数：时间单位</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        scheduledThreadPool.schedule(<span class="keyword">new</span> <span class="title class_">Task</span>(), <span class="number">0</span>, TimeUnit.SECONDS);</span><br><span class="line">        scheduledThreadPool.schedule(<span class="keyword">new</span> <span class="title class_">Task</span>(), <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">        scheduledThreadPool.schedule(<span class="keyword">new</span> <span class="title class_">Task</span>(), <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        scheduledThreadPool.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="3-5-为什么不建议用Executors创建线程池"><a href="#3-5-为什么不建议用Executors创建线程池" class="headerlink" title="3.5 为什么不建议用Executors创建线程池"></a>3.5 为什么不建议用Executors创建线程池</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p>参考阿里开发手册《Java开发手册-嵩山版》</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20220821003816845.png" alt="image-20220821003816845"></p>
<h3 id="3-6线程池的队列满了如何预警"><a href="#3-6线程池的队列满了如何预警" class="headerlink" title="3.6线程池的队列满了如何预警"></a>3.6线程池的队列满了如何预警</h3><p>当线程池的队列满了时，可以采取以下几种方法进行预警：</p>
<h4 id="1-自定义拒绝策略"><a href="#1-自定义拒绝策略" class="headerlink" title="1. 自定义拒绝策略"></a>1. <strong>自定义拒绝策略</strong></h4><p>线程池提供了多种拒绝策略（RejectionHandler），可以通过自定义拒绝策略来实现预警功能。例如，当队列满了时，可以发送告警信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomRejectedExecutionHandler</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> &#123;</span><br><span class="line">        <span class="comment">// 发送告警信息，比如日志记录或短信、邮件通知等</span></span><br><span class="line">        System.err.println(<span class="string">&quot;Task &quot;</span> + r.toString() + <span class="string">&quot; rejected from &quot;</span> + executor.toString());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 可以进一步扩展，将告警信息发送到监控系统</span></span><br><span class="line">        <span class="comment">// notifyMonitoringSystem(r, executor);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建线程池时使用自定义的拒绝策略</span></span><br><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">5</span>, <span class="number">10</span>, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">100</span>),</span><br><span class="line">    Executors.defaultThreadFactory(),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">CustomRejectedExecutionHandler</span>()</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="2-监控线程池状态"><a href="#2-监控线程池状态" class="headerlink" title="2. 监控线程池状态"></a>2. <strong>监控线程池状态</strong></h4><p>可以定期检查线程池的状态，并在队列接近满的时候发出预警。例如，通过定时任务监控线程池队列的大小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolMonitor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadPoolExecutor executor;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ScheduledExecutorService</span> <span class="variable">scheduler</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPoolMonitor</span><span class="params">(ThreadPoolExecutor executor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.executor = executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startMonitoring</span><span class="params">()</span> &#123;</span><br><span class="line">        scheduler.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">queueSize</span> <span class="operator">=</span> executor.getQueue().size();</span><br><span class="line">            <span class="type">int</span> <span class="variable">queueCapacity</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 假设队列容量为100</span></span><br><span class="line">            <span class="keyword">if</span> (queueSize &gt; queueCapacity * <span class="number">0.8</span>) &#123; <span class="comment">// 队列超过80%时预警</span></span><br><span class="line">                System.err.println(<span class="string">&quot;Warning: ThreadPool queue is &quot;</span> + queueSize + <span class="string">&quot; out of &quot;</span> + queueCapacity);</span><br><span class="line">                <span class="comment">// 发送告警信息到监控系统</span></span><br><span class="line">                <span class="comment">// notifyMonitoringSystem(queueSize, queueCapacity);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">5</span>, <span class="number">10</span>, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">100</span>)</span><br><span class="line">);</span><br><span class="line"><span class="type">ThreadPoolMonitor</span> <span class="variable">monitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolMonitor</span>(executor);</span><br><span class="line">monitor.startMonitoring();</span><br></pre></td></tr></table></figure>

<h4 id="3-使用监控工具"><a href="#3-使用监控工具" class="headerlink" title="3. 使用监控工具"></a>3. <strong>使用监控工具</strong></h4><p>可以借助一些现成的监控工具和框架来监控线程池状态并设置告警。例如，使用Micrometer、Prometheus等监控工具，这些工具可以轻松集成到Spring等框架中。</p>
<h4 id="4-日志分析"><a href="#4-日志分析" class="headerlink" title="4. 日志分析"></a>4. <strong>日志分析</strong></h4><p>将线程池的状态变化记录到日志中，并通过日志分析工具（如ELK Stack）进行监控和告警。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingRejectedExecutionHandler</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> &#123;</span><br><span class="line">        <span class="comment">// 记录到日志文件中</span></span><br><span class="line">        <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getLogger(<span class="string">&quot;ThreadPoolLogger&quot;</span>);</span><br><span class="line">        logger.warning(<span class="string">&quot;Task &quot;</span> + r.toString() + <span class="string">&quot; rejected from &quot;</span> + executor.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建线程池时使用日志记录的拒绝策略</span></span><br><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">5</span>, <span class="number">10</span>, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">100</span>),</span><br><span class="line">    Executors.defaultThreadFactory(),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">LoggingRejectedExecutionHandler</span>()</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>通过上述方法可以实现线程池队列满了时的预警，从而提高系统的稳定性和可靠性。</p>
<h3 id="3-7如何正确关闭线程池"><a href="#3-7如何正确关闭线程池" class="headerlink" title="3.7如何正确关闭线程池"></a>3.7如何正确关闭线程池</h3><p>说到如何正确去关闭一个线程池，这里面也有点讲究。为了实现优雅停机的目标，我们应当先调用shutdown方法，调用这个方法也就意味着，这个线程池不会再接收任何新的任务，但是已经提交的任务还会继续执行，包括队列中的。所以，之后你还应当调用awaitTermination方法，这个方法可以设定线程池在关闭之前的最大超时时间，如果在超时时间结束之前线程池能够正常关闭，这个方法会返回true，否则，一旦超时，就会返回false。通常来说我们不可能无限制地等待下去，因此需要我们事先预估一个合理的超时时间，然后去使用这个方法。</p>
<p>如果awaitTermination方法返回false，你又希望尽可能在线程池关闭之后再做其他资源回收工作，你可以考虑再调用一下shutdownNow方法，此时队列中所有尚未被处理的任务都会被丢弃，同时会设置线程池中每个线程的中断标志位。shutdownNow并不保证一定可以让正在运行的线程停止工作，除非提交给线程的任务能够正确响应中断。</p>
<h3 id="3-8使用单线程线程池优化方案"><a href="#3-8使用单线程线程池优化方案" class="headerlink" title="3.8使用单线程线程池优化方案"></a>3.8使用单线程线程池优化方案</h3><p><a target="_blank" rel="noopener" href="https://chatgpt.com/share/970432db-c2a6-47f4-af1e-5aacfdd57271">https://chatgpt.com/share/970432db-c2a6-47f4-af1e-5aacfdd57271</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全局IO密集型线程池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> ExecutorService instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造方法，防止外部实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">GlobalThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取全局唯一线程池实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 双重检查锁定，确保线程安全</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (GlobalThreadPool.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = createThreadPool();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService <span class="title function_">createThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">corePoolSize</span> <span class="operator">=</span> <span class="number">32</span>; <span class="comment">// 核心线程数（IO密集型为CPU核数*4）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maximumPoolSize</span> <span class="operator">=</span> <span class="number">40</span>; <span class="comment">// 最大线程数（IO密集型为CPU核数*5）</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">keepAliveTime</span> <span class="operator">=</span> <span class="number">60L</span>; <span class="comment">// 空闲线程存活时间（秒）</span></span><br><span class="line">        <span class="type">TimeUnit</span> <span class="variable">unit</span> <span class="operator">=</span> TimeUnit.SECONDS; <span class="comment">// 时间单位</span></span><br><span class="line">        BlockingQueue&lt;Runnable&gt; workQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">100</span>); <span class="comment">// 任务队列</span></span><br><span class="line">        <span class="type">ThreadFactory</span> <span class="variable">threadFactory</span> <span class="operator">=</span> Executors.defaultThreadFactory(); <span class="comment">// 线程工厂</span></span><br><span class="line">        <span class="type">RejectedExecutionHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomRejectedExecutionHandler</span>(); <span class="comment">// 自定义拒绝策略：用调用者所在的线程来执行任务，发送邮件，记录日志</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭线程池</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance != <span class="literal">null</span>) &#123;</span><br><span class="line">            instance.shutdown();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!instance.awaitTermination(<span class="number">60</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                    instance.shutdownNow();</span><br><span class="line">                    <span class="keyword">if</span> (!instance.awaitTermination(<span class="number">60</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                        log.error(<span class="string">&quot;线程池未能正常关闭&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                instance.shutdownNow();</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="线程池中-execute-和-submit-方法有什么区别？"><a href="#线程池中-execute-和-submit-方法有什么区别？" class="headerlink" title="线程池中 execute 和 submit 方法有什么区别？"></a>线程池中 execute 和 submit 方法有什么区别？</h3><p><strong>返回类型不同</strong>：</p>
<ul>
<li><code>execute(Runnable command)</code>：该方法用于提交一个不返回结果的任务。它没有返回值，也就是说，调用 <code>execute</code> 方法后不会返回任何对象，任务的结果（如果有的话）需要在任务内部处理。</li>
<li><code>submit(Callable&lt;T&gt; task)</code> 和 <code>submit(Runnable task)</code>：这两个方法用于提交任务并返回一个 <code>Future</code> 对象。<code>Future</code> 对象可以用于检查任务的状态，并且可以获取任务的执行结果或者在任务完成之前阻塞。</li>
</ul>
<p><strong>异常处理不同</strong>：</p>
<ul>
<li><code>execute(Runnable command)</code>：如果任务在执行过程中抛出异常，线程池将处理该异常并将其记录在 <code>ThreadPoolExecutor</code> 的未捕获异常处理器中。</li>
<li><code>submit(Callable&lt;T&gt; task)</code> 和 <code>submit(Runnable task)</code>：如果任务在执行过程中抛出异常，异常将被封装在返回的 <code>Future</code> 对象中，并且可以通过调用 <code>Future.get()</code> 方法来获取。<code>Future.get()</code> 将会在任务执行过程中抛出的任何异常包装成 <code>ExecutionException</code>。</li>
</ul>
<p><strong>任务类型不同</strong>：</p>
<ul>
<li><code>execute(Runnable command)</code>：只能提交实现了 <code>Runnable</code> 接口的任务，<code>Runnable</code> 接口的 <code>run</code> 方法没有返回值。</li>
<li><code>submit(Callable&lt;T&gt; task)</code>：可以提交实现了 <code>Callable</code> 接口的任务，<code>Callable</code> 接口的 <code>call</code> 方法有返回值。<code>submit(Runnable task)</code> 可以提交实现了 <code>Runnable</code> 接口的任务，但返回的 <code>Future</code> 的 <code>get</code> 方法将返回 <code>null</code>。</li>
</ul>
<h2 id="4-线程使用场景问题"><a href="#4-线程使用场景问题" class="headerlink" title="4.线程使用场景问题"></a>4.线程使用场景问题</h2><h3 id="4-1-线程池使用场景CountDownLatch、Future（你们项目哪里用到了多线程）"><a href="#4-1-线程池使用场景CountDownLatch、Future（你们项目哪里用到了多线程）" class="headerlink" title="4.1 线程池使用场景CountDownLatch、Future（你们项目哪里用到了多线程）"></a>4.1 线程池使用场景CountDownLatch、Future（你们项目哪里用到了多线程）</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<h4 id="4-1-2-案例一（es数据批量导入）"><a href="#4-1-2-案例一（es数据批量导入）" class="headerlink" title="4.1.2 案例一（es数据批量导入）"></a>4.1.2 案例一（es数据批量导入）</h4><p>在我们项目上线之前，我们需要把数据库中的数据一次性的同步到es索引库中，但是当时的数据好像是1000万左右，一次性读取数据肯定不行（oom异常），当时我就想到可以使用线程池的方式导入，利用CountDownLatch来控制，就能避免一次性加载过多，防止内存溢出</p>
<p>整体流程就是通过CountDownLatch+线程池配合去执行</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230505223219951.png" alt="image-20230505223219951"></p>
<p>详细实现流程：</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230505223246059.png" alt="image-20230505223246059"></p>
<blockquote>
<p>详细实现代码，请查看当天代码</p>
</blockquote>
<h4 id="4-1-3-案例二（数据汇总）"><a href="#4-1-3-案例二（数据汇总）" class="headerlink" title="4.1.3 案例二（数据汇总）"></a>4.1.3 案例二（数据汇总）</h4><p>在一个电商网站中，用户下单之后，需要查询数据，数据包含了三部分：订单信息、包含的商品、物流信息；这三块信息都在不同的微服务中进行实现的，我们如何完成这个业务呢？</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230505223442924.png" alt="image-20230505223442924"></p>
<blockquote>
<p>详细实现代码，请查看当天代码</p>
</blockquote>
<ul>
<li><p>在实际开发的过程中，难免需要调用多个接口来汇总数据，如果所有接口（或部分接口）的没有依赖关系，就可以使用线程池+future来提升性能</p>
</li>
<li><p>报表汇总</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230505223536657.png" alt="image-20230505223536657"></p>
</li>
</ul>
<h4 id="4-1-4-案例二（异步调用）"><a href="#4-1-4-案例二（异步调用）" class="headerlink" title="4.1.4 案例二（异步调用）"></a>4.1.4 案例二（异步调用）</h4><p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230505223640038.png" alt="image-20230505223640038"></p>
<p>在进行搜索的时候，需要保存用户的搜索记录，而搜索记录不能影响用户的正常搜索，我们通常会开启一个线程去执行历史记录的保存，在新开启的线程在执行的过程中，可以利用线程提交任务</p>
<h3 id="4-1-如何控制某个方法允许并发访问线程的数量？"><a href="#4-1-如何控制某个方法允许并发访问线程的数量？" class="headerlink" title="4.1 如何控制某个方法允许并发访问线程的数量？"></a>4.1 如何控制某个方法允许并发访问线程的数量？</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆</p>
</blockquote>
<p>Semaphore [ˈsɛməˌfɔr] 信号量，是JUC包下的一个工具类，我们可以通过其限制执行的线程数量，达到限流的效果</p>
<p>当一个线程执行时先通过其方法进行获取许可操作，获取到许可的线程继续执行业务逻辑，当线程执行完成后进行释放许可操作，未获取达到许可的线程进行等待或者直接结束。</p>
<p>Semaphore两个重要的方法</p>
<p>lsemaphore.acquire()： 请求一个信号量，这时候的信号量个数-1（一旦没有可使用的信号量，也即信号量个数变为负数时，再次请求的时候就会阻塞，直到其他线程释放了信号量）</p>
<p>lsemaphore.release()：释放一个信号量，此时信号量个数+1</p>
<p>线程任务类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreCase</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建 semaphore 对象</span></span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 2. 10个线程同时运行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 3. 获取许可</span></span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;end...&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 4. 释放许可</span></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-其他"><a href="#5-其他" class="headerlink" title="5.其他"></a>5.其他</h2><h3 id="5-1-谈谈你对ThreadLocal的理解"><a href="#5-1-谈谈你对ThreadLocal的理解" class="headerlink" title="5.1 谈谈你对ThreadLocal的理解"></a>5.1 谈谈你对ThreadLocal的理解</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<h4 id="5-1-1-概述"><a href="#5-1-1-概述" class="headerlink" title="5.1.1 概述"></a>5.1.1 概述</h4><p>ThreadLocal是多线程中对于解决线程安全的一个操作类，它会为每个线程都分配一个独立的线程副本从而解决了变量并发访问冲突的问题。ThreadLocal 同时实现了线程内的资源共享</p>
<p>案例：使用JDBC操作数据库时，会将每一个线程的Connection放入各自的ThreadLocal中，从而保证每个线程都在各自的 Connection 上进行数据库的操作，避免A线程关闭了B线程的连接。</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230505224057228.png" alt="image-20230505224057228"></p>
<h4 id="5-1-2-ThreadLocal基本使用"><a href="#5-1-2-ThreadLocal基本使用" class="headerlink" title="5.1.2 ThreadLocal基本使用"></a>5.1.2 ThreadLocal基本使用</h4><p>三个主要方法：</p>
<ul>
<li><p>set(value) 设置值</p>
</li>
<li><p>get() 获取值</p>
</li>
<li><p>remove() 清除值</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            threadLocal.set(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">            print(name);</span><br><span class="line">            System.out.println(name + <span class="string">&quot;-after remove : &quot;</span> + threadLocal.get());</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            threadLocal.set(<span class="string">&quot;itheima&quot;</span>);</span><br><span class="line">            print(name);</span><br><span class="line">            System.out.println(name + <span class="string">&quot;-after remove : &quot;</span> + threadLocal.get());</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="comment">//打印当前线程中本地内存中本地变量的值</span></span><br><span class="line">        System.out.println(str + <span class="string">&quot; :&quot;</span> + threadLocal.get());</span><br><span class="line">        <span class="comment">//清除本地内存中的本地变量</span></span><br><span class="line">        threadLocal.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-1-3-ThreadLocal的实现原理-源码解析"><a href="#5-1-3-ThreadLocal的实现原理-源码解析" class="headerlink" title="5.1.3 ThreadLocal的实现原理&amp;源码解析"></a>5.1.3 ThreadLocal的实现原理&amp;源码解析</h4><p>ThreadLocal本质来说就是一个线程内部存储类，从而让多个线程只操作自己内部的值，从而实现线程数据隔离</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230505224341410.png" alt="image-20230505224341410"></p>
<p>在ThreadLocal中有一个内部类叫做ThreadLocalMap，类似于HashMap</p>
<p>ThreadLocalMap中有一个属性table数组，这个是真正存储数据的位置</p>
<p><strong>set方法</strong></p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230505224626253.png" alt="image-20230505224626253"></p>
<p><strong>get方法&#x2F;remove方法</strong></p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230505224715087.png" alt="image-20230505224715087"></p>
<h4 id="5-1-4-ThreadLocal-内存泄露问题"><a href="#5-1-4-ThreadLocal-内存泄露问题" class="headerlink" title="5.1.4 ThreadLocal-内存泄露问题"></a>5.1.4 ThreadLocal-内存泄露问题</h4><p>Java对象中的四种引用类型：强引用、软引用、弱引用、虚引用</p>
<ul>
<li>强引用：最为普通的引用方式，表示一个对象处于有用且必须的状态，如果一个对象具有强引用，则GC并不会回收它。即便堆中内存不足了，宁可出现OOM，也不会对其进行回收</li>
</ul>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230505224755797.png" alt="image-20230505224755797"></p>
<ul>
<li>弱引用：表示一个对象处于可能有用且非必须的状态。在GC线程扫描内存区域时，一旦发现弱引用，就会回收到弱引用相关联的对象。对于弱引用的回收，无关内存区域是否足够，一旦发现则会被回收</li>
</ul>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230505224812015.png" alt="image-20230505224812015"></p>
<p>每一个Thread维护一个ThreadLocalMap，在ThreadLocalMap中的Entry对象继承了WeakReference。其中key为使用弱引用的ThreadLocal实例，value为线程变量的副本</p>
<p><img src="/../assets/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230505224857538.png" alt="image-20230505224857538"></p>
<p>在使用ThreadLocal的时候，强烈建议：<strong>务必手动remove</strong></p>
<h2 id="6-真实面试还原"><a href="#6-真实面试还原" class="headerlink" title="6 真实面试还原"></a>6 真实面试还原</h2><h3 id="6-1-线程的基础知识"><a href="#6-1-线程的基础知识" class="headerlink" title="6.1 线程的基础知识"></a>6.1 线程的基础知识</h3><blockquote>
<p><strong>面试官</strong>：聊一下并行和并发有什么区别？</p>
<p><strong>候选人：</strong></p>
<p>是这样的~~</p>
<p>现在都是多核CPU，在多核CPU下</p>
<p>并发是同一时间应对多件事情的能力，多个线程轮流使用一个或多个CPU</p>
<p>并行是同一时间动手做多件事情的能力，4核CPU同时执行4个线程</p>
<hr>
<p><strong>面试官</strong>：说一下线程和进程的区别？</p>
<p><strong>候选人：</strong></p>
<p>嗯，好~</p>
<ul>
<li>进程是正在运行程序的实例，进程中包含了线程，每个线程执行不同的任务</li>
<li>不同的进程使用不同的内存空间，在当前进程下的所有线程可以共享内存空间</li>
<li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低(上下文切换指的是从一个线程切换到另一个线程)</li>
</ul>
<hr>
<p><strong>面试官</strong>：如果在java中创建线程有哪些方式？</p>
<p><strong>候选人：</strong></p>
<p>在java中一共有四种常见的创建方式，分别是：继承Thread类、实现runnable接口、实现Callable接口、线程池创建线程。通常情况下，我们项目中都会采用线程池的方式创建线程。</p>
<p><strong>面试官</strong>：好的，刚才你说的runnable 和 callable 两个接口创建线程有什么不同呢？</p>
<p><strong>候选人：</strong></p>
<p>是这样的~</p>
<p>最主要的两个线程一个是有返回值，一个是没有返回值的。</p>
<p>Runnable 接口run方法无返回值；Callable接口call方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果</p>
<p>还有一个就是，他们异常处理也不一样。Runnable接口run方法只能抛出运行时异常，也无法捕获处理；Callable接口call方法允许抛出异常，可以获取异常信息</p>
<p>在实际开发中，如果需要拿到执行的结果，需要使用Callalbe接口创建线程，调用FutureTask.get()得到可以得到返回值，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。</p>
<hr>
<p><strong>面试官</strong>：线程包括哪些状态，状态之间是如何变化的？</p>
<p><strong>候选人：</strong></p>
<p>在JDK中的Thread类中的枚举State里面定义了6中线程的状态分别是：新建、可运行、终结、阻塞、等待和有时限等待六种。</p>
<p>关于线程的状态切换情况比较多。我分别介绍一下</p>
<p>当一个线程对象被创建，但还未调用 start 方法时处于<strong>新建</strong>状态，调用了 start 方法，就会由<strong>新建</strong>进入<strong>可运行</strong>状态。如果线程内代码已经执行完毕，由<strong>可运行</strong>进入<strong>终结</strong>状态。当然这些是一个线程正常执行情况。</p>
<p>如果线程获取锁失败后，由<strong>可运行</strong>进入 Monitor 的阻塞队列<strong>阻塞</strong>，只有当持锁线程释放锁时，会按照一定规则唤醒阻塞队列中的<strong>阻塞</strong>线程，唤醒后的线程进入<strong>可运行</strong>状态</p>
<p>如果线程获取锁成功后，但由于条件不满足，调用了 wait() 方法，此时从<strong>可运行</strong>状态释放锁<strong>等待</strong>状态，当其它持锁线程调用 notify() 或 notifyAll() 方法，会恢复为<strong>可运行</strong>状态</p>
<p>还有一种情况是调用 sleep(long) 方法也会从<strong>可运行</strong>状态进入<strong>有时限等待</strong>状态，不需要主动唤醒，超时时间到自然恢复为<strong>可运行</strong>状态</p>
<p><strong>面试官</strong>：嗯，好的，刚才你说的线程中的 wait 和 sleep方法有什么不同呢？</p>
<p><strong>候选人：</strong></p>
<p>它们两个的相同点是都可以让当前线程暂时放弃 CPU 的使用权，进入阻塞状态。</p>
<p>不同点主要有三个方面：</p>
<p>第一：方法归属不同</p>
<p>sleep(long) 是 Thread 的静态方法。而 wait()，是 Object 的成员方法，每个对象都有</p>
<p>第二：线程醒来时机不同</p>
<p>线程执行 sleep(long) 会在等待相应毫秒后醒来，而 wait() 需要被 notify 唤醒，wait() 如果不唤醒就一直等下去</p>
<p>第三：锁特性不同</p>
<p>wait 方法的调用必须先获取 wait 对象的锁，而 sleep 则无此限制</p>
<p>wait 方法执行后会释放对象锁，允许其它线程获得该对象锁（相当于我放弃 cpu，但你们还可以用）</p>
<p>而 sleep 如果在 synchronized 代码块中执行，并不会释放对象锁（相当于我放弃 cpu，你们也用不了）</p>
<p><strong>面试官</strong>：好的，我现在举一个场景，你来分析一下怎么做，新建 T1、T2、T3 三个线程，如何保证它们按顺序执行？</p>
<p><strong>候选人：</strong></p>
<p>嗯~~，我思考一下 （适当的思考或想一下属于正常情况，脱口而出反而太假[背诵痕迹]）</p>
<p>可以这么做，在多线程中有多种方法让线程按特定顺序执行，可以用线程类的<strong>join</strong>()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。</p>
<p>比如说：</p>
<p>使用join方法，T3调用T2，T2调用T1，这样就能确保T1就会先完成而T3最后完成</p>
<p><strong>面试官</strong>：在我们使用线程的过程中，有两个方法。线程的 run()和 start()有什么区别？</p>
<p><strong>候选人：</strong></p>
<p>start方法用来启动线程，通过该线程调用run方法执行run方法中所定义的逻辑代码。start方法只能被调用一次。run方法封装了要被线程执行的代码，可以被调用多次。</p>
<p><strong>面试官</strong>：那如何停止一个正在运行的线程呢？</p>
<p><strong>候选人</strong>：</p>
<p>有三种方式可以停止线程</p>
<p>第一：可以使用退出标志，使线程正常退出，也就是当run方法完成后线程终止，一般我们加一个标记</p>
<p>第二：可以使用线程的stop方法强行终止，不过一般不推荐，这个方法已作废</p>
<p>第三：可以使用线程的interrupt方法中断线程，内部其实也是使用中断标志来中断线程</p>
<p>我们项目中使用的话，建议使用第一种或第三种方式中断线程</p>
</blockquote>
<h3 id="6-2-线程中并发锁"><a href="#6-2-线程中并发锁" class="headerlink" title="6.2 线程中并发锁"></a>6.2 线程中并发锁</h3><blockquote>
<p><strong>面试官</strong>：讲一下synchronized关键字的底层原理？</p>
<p><strong>候选人</strong>：</p>
<p>嗯~~好的，</p>
<p>synchronized 底层使用的JVM级别中的Monitor 来决定当前线程是否获得了锁，如果某一个线程获得了锁，在没有释放锁之前，其他线程是不能或得到锁的。synchronized 属于悲观锁。</p>
<p>synchronized 因为需要依赖于JVM级别的Monitor ，相对性能也比较低。</p>
<p><strong>面试官</strong>：好的，你能具体说下Monitor 吗？</p>
<p><strong>候选人</strong>：</p>
<p>monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因</p>
<p>monitor内部维护了三个变量</p>
<ul>
<li><p>WaitSet：保存处于Waiting状态的线程</p>
</li>
<li><p>EntryList：保存处于Blocked状态的线程</p>
</li>
<li><p>Owner：持有锁的线程</p>
</li>
</ul>
<p>只有一个线程获取到的标志就是在monitor中设置成功了Owner，一个monitor中只能有一个Owner</p>
<p>在上锁的过程中，如果有其他线程也来抢锁，则进入EntryList 进行阻塞，当获得锁的线程执行完了，释放了锁，就会唤醒EntryList 中等待的线程竞争锁，竞争的时候是非公平的。</p>
<p><strong>面试官</strong>：好的，那关于synchronized 的锁升级的情况了解吗？</p>
<p><strong>候选人</strong>：</p>
<p>嗯，知道一些（要谦虚）</p>
<p>Java中的synchronized有偏向锁、轻量级锁、重量级锁三种形式，分别对应了锁只被一个线程持有、不同线程交替持有锁、多线程竞争锁三种情况。</p>
<p>重量级锁：底层使用的Monitor实现，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高，性能比较低。</p>
<p>轻量级锁：线程加锁的时间是错开的（也就是没有竞争），可以使用轻量级锁来优化。轻量级修改了对象头的锁标志，相对重量级锁性能提升很多。每次修改都是CAS操作，保证原子性</p>
<p>偏向锁：一段很长的时间内都只被一个线程使用锁，可以使用了偏向锁，在第一次获得锁时，会有一个CAS操作，之后该线程再获取锁，只需要判断mark word中是否是自己的线程id即可，而不是开销相对较大的CAS命令</p>
<p>一旦锁发生了竞争，都会升级为重量级锁</p>
<p><strong>面试官</strong>：好的，刚才你说了synchronized它在高并发量的情况下，性能不高，在项目该如何控制使用锁呢？</p>
<p><strong>候选人</strong>：</p>
<p>嗯，其实，在高并发下，我们可以采用ReentrantLock来加锁。</p>
<p><strong>面试官</strong>：嗯，那你说下ReentrantLock的使用方式和底层原理？</p>
<p><strong>候选人</strong>：</p>
<p>好的，</p>
<p>ReentrantLock是一个可重入锁:，调用 lock 方 法获取了锁之后，再次调用 lock，是不会再阻塞，内部直接增加重入次数 就行了，标识这个线程已经重复获取一把锁而不需要等待锁的释放。</p>
<p>ReentrantLock是属于juc报下的类，属于api层面的锁，跟synchronized一样，都是悲观锁。通过lock()用来获取锁，unlock()释放锁。</p>
<p>它的底层实现原理主要利用<strong>CAS+AQS队列</strong>来实现。它支持公平锁和非公平锁，两者的实现类似</p>
<p>构造方法接受一个可选的公平参数（<strong>默认非公平锁</strong>），当设置为true时，表示公平锁，否则为非公平锁。公平锁的效率往往没有非公平锁的效率高。</p>
<p><strong>面试官</strong>：好的，刚才你说了CAS和AQS，你能介绍一下吗？</p>
<p><strong>候选人</strong>：</p>
<p>好的。</p>
<p>CAS的全称是： Compare And Swap(比较再交换);它体现的一种乐观锁的思想，在无锁状态下保证线程操作数据的原子性。</p>
<ul>
<li><p>CAS使用到的地方很多：AQS框架、AtomicXXX类</p>
</li>
<li><p>在操作共享变量的时候使用的自旋锁，效率上更高一些</p>
</li>
<li><p>CAS的底层是调用的Unsafe类中的方法，都是操作系统提供的，其他语言实现</p>
</li>
</ul>
<p>AQS的话，其实就一个jdk提供的类AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架。</p>
<p>内部有一个属性 state 属性来表示资源的状态，默认state等于0，表示没有获取锁，state等于1的时候才标明获取到了锁。通过cas 机制设置 state 状态</p>
<p>在它的内部还提供了基于 FIFO 的等待队列，是一个双向列表，其中</p>
<ul>
<li><p>tail 指向队列最后一个元素</p>
</li>
<li><p>head  指向队列中最久的一个元素</p>
</li>
</ul>
<p>其中我们刚刚聊的ReentrantLock底层的实现就是一个AQS。</p>
<p><strong>面试官</strong>：synchronized和Lock有什么区别 ? 	</p>
<p><strong>候选人</strong>：</p>
<p>嗯~~，好的，主要有三个方面不太一样</p>
<p>第一，语法层面</p>
<ul>
<li>synchronized 是关键字，源码在 jvm 中，用 c++ 语言实现，退出同步代码块锁会自动释放</li>
<li>Lock 是接口，源码由 jdk 提供，用 java 语言实现，需要手动调用 unlock 方法释放锁</li>
</ul>
<p>第二，功能层面</p>
<ul>
<li>二者均属于悲观锁、都具备基本的互斥、同步、锁重入功能</li>
<li>Lock 提供了许多 synchronized 不具备的功能，例如获取等待状态、公平锁、可打断、可超时、多条件变量，同时Lock 可以实现不同的场景，如 ReentrantLock， ReentrantReadWriteLock</li>
</ul>
<p>第三，性能层面</p>
<ul>
<li>在没有竞争时，synchronized 做了很多优化，如偏向锁、轻量级锁，性能不赖</li>
<li>在竞争激烈时，Lock 的实现通常会提供更好的性能</li>
</ul>
<p>统合来看，需要根据不同的场景来选择不同的锁的使用。</p>
<hr>
<p><strong>面试官</strong>：死锁产生的条件是什么？</p>
<p><strong>候选人</strong>：</p>
<p>嗯，是这样的，一个线程需要同时获取多把锁，这时就容易发生死锁，举个例子来说：</p>
<p>t1 线程获得A对象锁，接下来想获取B对象的锁</p>
<p>t2 线程获得B对象锁，接下来想获取A对象的锁 </p>
<p>这个时候t1线程和t2线程都在互相等待对方的锁，就产生了死锁</p>
<p><strong>面试官</strong>：那如果产出了这样的，如何进行死锁诊断？</p>
<p><strong>候选人</strong>：</p>
<p>这个也很容易，我们只需要通过jdk自动的工具就能搞定</p>
<p>我们可以先通过jps来查看当前java程序运行的进程id</p>
<p>然后通过jstack来查看这个进程id，就能展示出来死锁的问题，并且，可以定位代码的具体行号范围，我们再去找到对应的代码进行排查就行了。</p>
<hr>
<p><strong>面试官</strong>：请谈谈你对 volatile 的理解</p>
<p><strong>候选人</strong>：</p>
<p>嗯~~</p>
<p>volatile 是一个关键字，可以修饰类的成员变量、类的静态成员变量，主要有两个功能</p>
<p>第一：保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的,volatile关键字会强制将修改的值立即写入主存。</p>
<p>第二： 禁止进行指令重排序，可以保证代码执行有序性。底层实现原理是，添加了一个<strong>内存屏障</strong>，通过插入内存屏障禁止在内存屏障<strong>前后</strong>的指令执行重排序优化</p>
<hr>
<p><strong>本文作者</strong>：接《集合相关面试题》</p>
<p><strong>面试官</strong>：那你能聊一下ConcurrentHashMap的原理吗？</p>
<p><strong>候选人</strong>：</p>
<p>嗯好的，</p>
<p>ConcurrentHashMap 是一种线程安全的高效Map集合，jdk1.7和1.8也做了很多调整。</p>
<ul>
<li>JDK1.7的底层采用是<strong>分段的数组</strong>+<strong>链表</strong> 实现</li>
<li>JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表&#x2F;红黑二叉树。</li>
</ul>
<p>在jdk1.7中 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一 种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构 的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修 改时，必须首先获得对应的 Segment的锁。</p>
<p>Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元 素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁</p>
<p>在jdk1.8中的ConcurrentHashMap 做了较大的优化，性能提升了不少。首先是它的数据结构与jdk1.8的hashMap数据结构完全一致。其次是放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保 证并发安全进行实现，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲 突，就不会产生并发 , 效率得到提升</p>
</blockquote>
<h3 id="6-3-线程池"><a href="#6-3-线程池" class="headerlink" title="6.3 线程池"></a>6.3 线程池</h3><blockquote>
<p><strong>面试官</strong>：线程池的种类有哪些？</p>
<p><strong>候选人</strong>：</p>
<p>嗯！是这样</p>
<p>在jdk中默认提供了4中方式创建线程池</p>
<p>第一个是：newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回 收空闲线程，若无可回收，则新建线程。 </p>
<p>第二个是：newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列 中等待。 </p>
<p>第三个是：newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。 </p>
<p>第四个是：newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任 务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p>
<p><strong>面试官</strong>：线程池的核心参数有哪些？</p>
<p><strong>候选人</strong>：</p>
<p>在线程池中一共有7个核心参数：</p>
<ol>
<li><p>corePoolSize 核心线程数目 - 池中会保留的最多线程数</p>
</li>
<li><p>maximumPoolSize 最大线程数目 - 核心线程+救急线程的最大数目</p>
</li>
<li><p>keepAliveTime 生存时间 - 救急线程的生存时间，生存时间内没有新任务，此线程资源会释放</p>
</li>
<li><p>unit 时间单位 - 救急线程的生存时间单位，如秒、毫秒等</p>
</li>
<li><p>workQueue - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务</p>
</li>
<li><p>threadFactory 线程工厂 - 可以定制线程对象的创建，例如设置线程名字、是否是守护线程等</p>
</li>
<li><p>handler 拒绝策略 - 当所有线程都在繁忙，workQueue 也放满时，会触发拒绝策略</p>
</li>
</ol>
<p>  在拒绝策略中又有4中拒绝策略</p>
<p>  当线程数过多以后，第一种是抛异常、第二种是由调用者执行任务、第三是丢弃当前的任务，第四是丢弃最早排队任务。默认是直接抛异常。</p>
<p><strong>面试官</strong>：如何确定核心线程池呢？</p>
<p><strong>候选人</strong>：</p>
<p>是这样的，我们公司当时有一些规范，为了减少线程上下文的切换，要根据当时部署的服务器的CPU核数来决定，我们规则是：CPU核数+1就是最终的核心线程数。</p>
<p><strong>面试官</strong>：线程池的执行原理知道吗？</p>
<p><strong>候选人</strong>：</p>
<p>嗯~，它是这样的</p>
<p>首先判断线程池里的核心线程是否都在执行任务，如果不是则创建一个新的工作线程来执行任务。如果核心线程都在执行任务，则线程池判断工作队列是否已满，如果工作队列没有满，则将新提交的任务存储在这个工作队 列里。如果工作队列满了，则判断线程池里的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任 务。如果已经满了，则交给拒绝策略来处理这个任务。</p>
<p><strong>面试官</strong>：为什么不建议使用Executors创建线程池呢？</p>
<p><strong>候选人</strong>：</p>
<p>好的，其实这个事情在阿里提供的最新开发手册《Java开发手册-嵩山版》中也提到了</p>
<p>主要原因是如果使用Executors创建线程池的话，它允许的请求队列默认长度是Integer.MAX_VALUE，这样的话，有可能导致堆积大量的请求，从而导致OOM（内存溢出）。</p>
<p>所以，我们一般推荐使用ThreadPoolExecutor来创建线程池，这样可以明确规定线程池的参数，避免资源的耗尽。</p>
</blockquote>
<h3 id="6-4-线程使用场景问题"><a href="#6-4-线程使用场景问题" class="headerlink" title="6.4 线程使用场景问题"></a>6.4 线程使用场景问题</h3><blockquote>
<p><strong>面试官</strong>：如果控制某一个方法允许并发访问线程的数量？</p>
<p><strong>候选人</strong>：</p>
<p>嗯~~，我想一下</p>
<p>在jdk中提供了一个Semaphore[seməfɔːr]类（信号量）</p>
<p>它提供了两个方法，semaphore.acquire() 请求信号量，可以限制线程的个数，是一个正数，如果信号量是-1,就代表已经用完了信号量，其他线程需要阻塞了</p>
<p>第二个方法是semaphore.release()，代表是释放一个信号量，此时信号量的个数+1</p>
<p><strong>面试官</strong>：好的，那该如何保证Java程序在多线程的情况下执行安全呢？</p>
<p><strong>候选人</strong>：</p>
<p>嗯，刚才讲过了导致线程安全的原因，如果解决的话，jdk中也提供了很多的类帮助我们解决多线程安全的问题，比如：</p>
<ul>
<li>JDK Atomic开头的原子类、synchronized、LOCK，可以解决原子性问题</li>
<li>synchronized、volatile、LOCK，可以解决可见性问题</li>
<li>Happens-Before 规则可以解决有序性问题</li>
</ul>
<hr>
<p><strong>面试官</strong>：你在项目中哪里用了多线程？</p>
<p><strong>候选人</strong>：</p>
<p>嗯~~，我想一下当时的场景[根据自己简历上的模块设计多线程场景]</p>
<p>参考场景一：</p>
<p>es数据批量导入</p>
<p>在我们项目上线之前，我们需要把数据量的数据一次性的同步到es索引库中，但是当时的数据好像是1000万左右，一次性读取数据肯定不行（oom异常），如果分批执行的话，耗时也太久了。所以，当时我就想到可以使用线程池的方式导入，利用CountDownLatch+Future来控制，就能大大提升导入的时间。</p>
<p>参考场景二：</p>
<p>在我做那个xx电商网站的时候，里面有一个数据汇总的功能，在用户下单之后需要查询订单信息，也需要获得订单中的商品详细信息（可能是多个），还需要查看物流发货信息。因为它们三个对应的分别三个微服务，如果一个一个的操作的话，互相等待的时间比较长。所以，我当时就想到可以使用线程池，让多个线程同时处理，最终再汇总结果就可以了，当然里面需要用到Future来获取每个线程执行之后的结果才行</p>
<p>参考场景三：</p>
<p>《黑马头条》项目中使用的</p>
<p>我当时做了一个文章搜索的功能，用户输入关键字要搜索文章，同时需要保存用户的搜索记录（搜索历史），这块我设计的时候，为了不影响用户的正常搜索，我们采用的异步的方式进行保存的，为了提升性能，我们加入了线程池，也就说在调用异步方法的时候，直接从线程池中获取线程使用</p>
</blockquote>
<h3 id="6-5-其他"><a href="#6-5-其他" class="headerlink" title="6.5 其他"></a>6.5 其他</h3><blockquote>
<p><strong>面试官</strong>：谈谈你对ThreadLocal的理解</p>
<p><strong>候选人</strong>：</p>
<p>嗯，是这样的~~</p>
<p>ThreadLocal 主要功能有两个，第一个是可以<strong>实现资源对象的线程隔离</strong>，让每个线程各用各的资源对象，避免争用引发的线程安全问题，第二个是实现了<strong>线程内的资源共享</strong></p>
<p><strong>面试官</strong>：好的，那你知道ThreadLocal的底层原理实现吗？</p>
<p><strong>候选人</strong>：</p>
<p>嗯，知道一些~</p>
<p>在ThreadLocal内部维护了一个一个 ThreadLocalMap 类型的成员变量，用来存储资源对象</p>
<p>当我们调用 set 方法，就是以 ThreadLocal 自己作为 key，资源对象作为 value，放入当前线程的 ThreadLocalMap 集合中</p>
<p>当调用 get 方法，就是以 ThreadLocal 自己作为 key，到当前线程中查找关联的资源值</p>
<p>当调用 remove 方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值</p>
<p><strong>面试官</strong>：好的，那关于ThreadLocal会导致内存溢出这个事情，了解吗？</p>
<p><strong>候选人</strong>：</p>
<p>嗯，我之前看过源码，我想一下~~</p>
<p>是应为ThreadLocalMap 中的 key 被设计为弱引用，它是被动的被GC调用释放key，不过关键的是只有key可以得到内存释放，而value不会，因为value是一个强引用。</p>
<p>在使用ThreadLocal 时都把它作为静态变量（即强引用），因此无法被动依靠 GC 回收，建议主动的remove 释放 key，这样就能避免内存溢出。</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://PlanBBBBB.github.io">PlanB</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://planbbbbb.github.io/2024/01/06/%E9%9D%A2%E8%AF%95-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/">https://planbbbbb.github.io/2024/01/06/%E9%9D%A2%E8%AF%95-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://PlanBBBBB.github.io" target="_blank">PlanB's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></div><div class="post_share"><div class="social-share" data-image="/../img/%E5%A4%9A%E7%BA%BF%E7%A8%8B.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/12/30/Study-ElasticSearch/"><img class="prev-cover" src="/../img/es.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">ElasticSearch</div></div></a></div><div class="next-post pull-right"><a href="/2024/01/08/%E9%9D%A2%E8%AF%95-Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/"><img class="next-cover" src="/../img/java%E9%9B%86%E5%90%88.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java集合相关面试题</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/08/28/Study-JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="JUC并发编程"><img class="cover" src="/../img/juc.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-28</div><div class="title">JUC并发编程</div></div></a></div><div><a href="/2024/06/01/Study-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="Java并发编程"><img class="cover" src="/../img/juc.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-01</div><div class="title">Java并发编程</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/%E5%A4%B4%E5%83%8F.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">PlanB</div><div class="author-info__description">欢迎来到PlanB的博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">61</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/PlanBBBBB"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/PlanBBBBB" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2741718884@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到PlanB的博客！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="toc-number">1.</span> <span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">Java多线程相关面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">2.1.</span> <span class="toc-text">1.线程的基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.1 线程和进程的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.1.2.</span> <span class="toc-text">1.2 并行和并发有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">2.1.3.</span> <span class="toc-text">1.3 创建线程的四种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-runnable-%E5%92%8C-callable-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">2.1.4.</span> <span class="toc-text">1.4 runnable 和 callable 有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E7%BA%BF%E7%A8%8B%E7%9A%84-run-%E5%92%8C-start-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.1.5.</span> <span class="toc-text">1.5 线程的 run()和 start()有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-%E7%BA%BF%E7%A8%8B%E5%8C%85%E6%8B%AC%E5%93%AA%E4%BA%9B%E7%8A%B6%E6%80%81%EF%BC%8C%E7%8A%B6%E6%80%81%E4%B9%8B%E9%97%B4%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%98%E5%8C%96%E7%9A%84"><span class="toc-number">2.1.6.</span> <span class="toc-text">1.6 线程包括哪些状态，状态之间是如何变化的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-%E6%96%B0%E5%BB%BA-T1%E3%80%81T2%E3%80%81T3-%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%AE%83%E4%BB%AC%E6%8C%89%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%EF%BC%9F"><span class="toc-number">2.1.7.</span> <span class="toc-text">1.7 新建 T1、T2、T3 三个线程，如何保证它们按顺序执行？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-notify-%E5%92%8C-notifyAll-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.1.8.</span> <span class="toc-text">1.8 notify()和 notifyAll()有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-9-%E5%9C%A8-java-%E4%B8%AD-wait-%E5%92%8C-sleep-%E6%96%B9%E6%B3%95%E7%9A%84%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">2.1.9.</span> <span class="toc-text">1.9 在 java 中 wait 和 sleep 方法的不同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-10-%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2%E4%B8%80%E4%B8%AA%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">2.1.10.</span> <span class="toc-text">1.10 如何停止一个正在运行的线程？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%BA%BF%E7%A8%8B%E4%B8%AD%E5%B9%B6%E5%8F%91%E9%94%81"><span class="toc-number">2.2.</span> <span class="toc-text">2.线程中并发锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E8%AE%B2%E4%B8%80%E4%B8%8Bsynchronized%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.1 讲一下synchronized关键字的底层原理？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">2.1.1 基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-Monitor"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">2.1.2 Monitor</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-%E8%BF%9B%E9%98%B6"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2 synchronized关键字的底层原理-进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">2.2.1 对象的内存结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-MarkWord"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">2.2.2 MarkWord</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-%E5%86%8D%E8%AF%B4Monitor%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">2.2.3 再说Monitor重量级锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-4-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">2.2.2.4.</span> <span class="toc-text">2.2.4 轻量级锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-5-%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-number">2.2.2.5.</span> <span class="toc-text">2.2.5 偏向锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-6-%E5%8F%82%E8%80%83%E5%9B%9E%E7%AD%94"><span class="toc-number">2.2.2.6.</span> <span class="toc-text">2.2.6 参考回答</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sychronized%E5%92%8CReentrantLock%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.3.</span> <span class="toc-text">Sychronized和ReentrantLock区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E7%8A%B6%E6%80%81%E5%8D%87%E7%BA%A7%E6%80%BB%E7%BB%93"><span class="toc-number">2.2.4.</span> <span class="toc-text">锁的状态升级总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%97%A0%E9%94%81%E7%8A%B6%E6%80%81%EF%BC%88Unlocked%EF%BC%89"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">1. 无锁状态（Unlocked）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">2.2.4.1.1.</span> <span class="toc-text">特点：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-number">2.2.4.1.2.</span> <span class="toc-text">实现：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">2.2.4.1.3.</span> <span class="toc-text">适用场景：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%81%8F%E5%90%91%E9%94%81%EF%BC%88Biased-Locking%EF%BC%89"><span class="toc-number">2.2.4.2.</span> <span class="toc-text">2. 偏向锁（Biased Locking）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A-1"><span class="toc-number">2.2.4.2.1.</span> <span class="toc-text">特点：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%EF%BC%9A-1"><span class="toc-number">2.2.4.2.2.</span> <span class="toc-text">实现：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%87%E7%BA%A7%E6%83%85%E5%86%B5%EF%BC%9A"><span class="toc-number">2.2.4.2.3.</span> <span class="toc-text">升级情况：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A-1"><span class="toc-number">2.2.4.2.4.</span> <span class="toc-text">适用场景：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%EF%BC%88Lightweight-Locking%EF%BC%89"><span class="toc-number">2.2.4.3.</span> <span class="toc-text">3. 轻量级锁（Lightweight Locking）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A-2"><span class="toc-number">2.2.4.3.1.</span> <span class="toc-text">特点：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%EF%BC%9A-2"><span class="toc-number">2.2.4.3.2.</span> <span class="toc-text">实现：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%87%E7%BA%A7%E6%83%85%E5%86%B5%EF%BC%9A-1"><span class="toc-number">2.2.4.3.3.</span> <span class="toc-text">升级情况：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A-2"><span class="toc-number">2.2.4.3.4.</span> <span class="toc-text">适用场景：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%EF%BC%88Heavyweight-Locking%EF%BC%89"><span class="toc-number">2.2.4.4.</span> <span class="toc-text">4. 重量级锁（Heavyweight Locking）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A-3"><span class="toc-number">2.2.4.4.1.</span> <span class="toc-text">特点：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%EF%BC%9A-3"><span class="toc-number">2.2.4.4.2.</span> <span class="toc-text">实现：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%87%E7%BA%A7%E6%83%85%E5%86%B5%EF%BC%9A-2"><span class="toc-number">2.2.4.4.3.</span> <span class="toc-text">升级情况：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A-3"><span class="toc-number">2.2.4.4.4.</span> <span class="toc-text">适用场景：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E6%B5%81%E7%A8%8B"><span class="toc-number">2.2.4.5.</span> <span class="toc-text">锁的状态转换流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.2.4.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E4%BD%A0%E8%B0%88%E8%B0%88-JMM%EF%BC%88Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%89"><span class="toc-number">2.2.5.</span> <span class="toc-text">2.3你谈谈 JMM（Java 内存模型）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-CAS-%E4%BD%A0%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F"><span class="toc-number">2.2.6.</span> <span class="toc-text">2.4 CAS 你知道吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-%E6%A6%82%E8%BF%B0%E5%8F%8A%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">2.2.6.1.</span> <span class="toc-text">2.4.1 概述及基本工作流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-CAS-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.6.2.</span> <span class="toc-text">2.4.2 CAS 底层实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3-%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.6.3.</span> <span class="toc-text">2.4.3 乐观锁和悲观锁的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E8%AF%B7%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-volatile-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">2.2.7.</span> <span class="toc-text">2.5 请谈谈你对 volatile 的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-1-%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">2.2.7.1.</span> <span class="toc-text">2.5.1 保证线程间的可见性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-2-%E7%A6%81%E6%AD%A2%E8%BF%9B%E8%A1%8C%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F"><span class="toc-number">2.2.7.2.</span> <span class="toc-text">2.5.2 禁止进行指令重排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E4%BB%80%E4%B9%88%E6%98%AFAQS%EF%BC%9F"><span class="toc-number">2.2.8.</span> <span class="toc-text">2.6 什么是AQS？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">2.2.8.1.</span> <span class="toc-text">2.6.1 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-2-%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-number">2.2.8.2.</span> <span class="toc-text">2.6.2 工作机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-ReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.2.9.</span> <span class="toc-text">2.5 ReentrantLock的实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">2.2.9.1.</span> <span class="toc-text">2.5.1 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-2-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.2.9.2.</span> <span class="toc-text">2.5.2 实现原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-synchronized%E5%92%8CLock%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.10.</span> <span class="toc-text">2.6 synchronized和Lock有什么区别 ?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E6%9D%A1%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.2.11.</span> <span class="toc-text">2.7 死锁产生的条件是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%AD%BB%E9%94%81%E8%AF%8A%E6%96%AD%EF%BC%9F"><span class="toc-number">2.2.12.</span> <span class="toc-text">2.8 如何进行死锁诊断？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-10-ConcurrentHashMap"><span class="toc-number">2.2.13.</span> <span class="toc-text">2.10  ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89-JDK1-7%E4%B8%ADconcurrentHashMap"><span class="toc-number">2.2.13.1.</span> <span class="toc-text">（1） JDK1.7中concurrentHashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89-JDK1-8%E4%B8%ADconcurrentHashMap"><span class="toc-number">2.2.13.2.</span> <span class="toc-text">（2） JDK1.8中concurrentHashMap</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-11-%E5%AF%BC%E8%87%B4%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E7%9A%84%E6%A0%B9%E6%9C%AC%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.2.14.</span> <span class="toc-text">2.11 导致并发程序出现问题的根本原因是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">2.2.14.1.</span> <span class="toc-text">（1）原子性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">2.2.14.2.</span> <span class="toc-text">（2）内存可见性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-number">2.2.14.3.</span> <span class="toc-text">（3）有序性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">2.3.</span> <span class="toc-text">3.线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E8%AF%B4%E4%B8%80%E4%B8%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E7%9F%A5%E9%81%93%E5%98%9B%EF%BC%89"><span class="toc-number">2.3.1.</span> <span class="toc-text">3.1 说一下线程池的核心参数（线程池的执行原理知道嘛）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">2.3.2.</span> <span class="toc-text">3.2 线程池中有哪些常见的阻塞队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedBlockingQueue"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">LinkedBlockingQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayBlockingQueue"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">ArrayBlockingQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%BD%B1%E5%93%8D"><span class="toc-number">2.3.2.3.</span> <span class="toc-text">性能影响</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%95%B0"><span class="toc-number">2.3.3.</span> <span class="toc-text">3.3 如何确定核心线程数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%A7%8D%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">2.3.4.</span> <span class="toc-text">3.4 线程池的种类有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E7%94%A8Executors%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">2.3.5.</span> <span class="toc-text">3.5 为什么不建议用Executors创建线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E9%98%9F%E5%88%97%E6%BB%A1%E4%BA%86%E5%A6%82%E4%BD%95%E9%A2%84%E8%AD%A6"><span class="toc-number">2.3.6.</span> <span class="toc-text">3.6线程池的队列满了如何预警</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="toc-number">2.3.6.1.</span> <span class="toc-text">1. 自定义拒绝策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%9B%91%E6%8E%A7%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81"><span class="toc-number">2.3.6.2.</span> <span class="toc-text">2. 监控线程池状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7"><span class="toc-number">2.3.6.3.</span> <span class="toc-text">3. 使用监控工具</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90"><span class="toc-number">2.3.6.4.</span> <span class="toc-text">4. 日志分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">2.3.7.</span> <span class="toc-text">3.7如何正确关闭线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8%E4%BD%BF%E7%94%A8%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88"><span class="toc-number">2.3.8.</span> <span class="toc-text">3.8使用单线程线程池优化方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD-execute-%E5%92%8C-submit-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.3.9.</span> <span class="toc-text">线程池中 execute 和 submit 方法有什么区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.</span> <span class="toc-text">4.线程使用场景问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AFCountDownLatch%E3%80%81Future%EF%BC%88%E4%BD%A0%E4%BB%AC%E9%A1%B9%E7%9B%AE%E5%93%AA%E9%87%8C%E7%94%A8%E5%88%B0%E4%BA%86%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%89"><span class="toc-number">2.4.1.</span> <span class="toc-text">4.1 线程池使用场景CountDownLatch、Future（你们项目哪里用到了多线程）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-%E6%A1%88%E4%BE%8B%E4%B8%80%EF%BC%88es%E6%95%B0%E6%8D%AE%E6%89%B9%E9%87%8F%E5%AF%BC%E5%85%A5%EF%BC%89"><span class="toc-number">2.4.1.1.</span> <span class="toc-text">4.1.2 案例一（es数据批量导入）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3-%E6%A1%88%E4%BE%8B%E4%BA%8C%EF%BC%88%E6%95%B0%E6%8D%AE%E6%B1%87%E6%80%BB%EF%BC%89"><span class="toc-number">2.4.1.2.</span> <span class="toc-text">4.1.3 案例二（数据汇总）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-4-%E6%A1%88%E4%BE%8B%E4%BA%8C%EF%BC%88%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%EF%BC%89"><span class="toc-number">2.4.1.3.</span> <span class="toc-text">4.1.4 案例二（异步调用）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E6%9F%90%E4%B8%AA%E6%96%B9%E6%B3%95%E5%85%81%E8%AE%B8%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%95%B0%E9%87%8F%EF%BC%9F"><span class="toc-number">2.4.2.</span> <span class="toc-text">4.1 如何控制某个方法允许并发访问线程的数量？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%85%B6%E4%BB%96"><span class="toc-number">2.5.</span> <span class="toc-text">5.其他</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9ThreadLocal%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">2.5.1.</span> <span class="toc-text">5.1 谈谈你对ThreadLocal的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">2.5.1.1.</span> <span class="toc-text">5.1.1 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-2-ThreadLocal%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">2.5.1.2.</span> <span class="toc-text">5.1.2 ThreadLocal基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-3-ThreadLocal%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">2.5.1.3.</span> <span class="toc-text">5.1.3 ThreadLocal的实现原理&amp;源码解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-4-ThreadLocal-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98"><span class="toc-number">2.5.1.4.</span> <span class="toc-text">5.1.4 ThreadLocal-内存泄露问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%9C%9F%E5%AE%9E%E9%9D%A2%E8%AF%95%E8%BF%98%E5%8E%9F"><span class="toc-number">2.6.</span> <span class="toc-text">6 真实面试还原</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">2.6.1.</span> <span class="toc-text">6.1 线程的基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E7%BA%BF%E7%A8%8B%E4%B8%AD%E5%B9%B6%E5%8F%91%E9%94%81"><span class="toc-number">2.6.2.</span> <span class="toc-text">6.2 线程中并发锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">2.6.3.</span> <span class="toc-text">6.3 线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E9%97%AE%E9%A2%98"><span class="toc-number">2.6.4.</span> <span class="toc-text">6.4 线程使用场景问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-%E5%85%B6%E4%BB%96"><span class="toc-number">2.6.5.</span> <span class="toc-text">6.5 其他</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/08/04/Project-AIGC%E5%B9%BF%E5%91%8A%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/" title="AIGC 广告推荐系统"><img src="/../img/AI.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AIGC 广告推荐系统"/></a><div class="content"><a class="title" href="/2024/08/04/Project-AIGC%E5%B9%BF%E5%91%8A%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/" title="AIGC 广告推荐系统">AIGC 广告推荐系统</a><time datetime="2024-08-04T03:55:21.188Z" title="发表于 2024-08-04 11:55:21">2024-08-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/24/Study-Flyway/" title="Flyway"><img src="/../img/Flyway.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Flyway"/></a><div class="content"><a class="title" href="/2024/07/24/Study-Flyway/" title="Flyway">Flyway</a><time datetime="2024-07-24T11:40:44.628Z" title="发表于 2024-07-24 19:40:44">2024-07-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/22/Study-Nginx/" title="Nginx"><img src="/../img/nginx.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Nginx"/></a><div class="content"><a class="title" href="/2024/07/22/Study-Nginx/" title="Nginx">Nginx</a><time datetime="2024-07-22T13:58:09.430Z" title="发表于 2024-07-22 21:58:09">2024-07-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/22/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络面试篇"><img src="/../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络面试篇"/></a><div class="content"><a class="title" href="/2024/07/22/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络面试篇">计算机网络面试篇</a><time datetime="2024-07-22T11:36:06.129Z" title="发表于 2024-07-22 19:36:06">2024-07-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/21/Study-%E6%B6%88%E6%81%AF%E5%AE%9E%E6%97%B6%E6%8E%A8%E9%80%81/" title="消息实时推送汇总"><img src="/../img/%E6%B6%88%E6%81%AF%E5%AE%9E%E6%97%B6%E6%8E%A8%E9%80%81.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="消息实时推送汇总"/></a><div class="content"><a class="title" href="/2024/07/21/Study-%E6%B6%88%E6%81%AF%E5%AE%9E%E6%97%B6%E6%8E%A8%E9%80%81/" title="消息实时推送汇总">消息实时推送汇总</a><time datetime="2024-07-21T13:34:41.317Z" title="发表于 2024-07-21 21:34:41">2024-07-21</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By PlanB</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://PlanBBBBB.github.io">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script async src="/js/title.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="0基础,学IT" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(./img/project.png);"> <a class="categoryBar-list-link" href="categories/Project/">Project</a><span class="categoryBar-list-count">7</span><span class="categoryBar-list-descr">Poject</span></li><li class="categoryBar-list-item" style="background:url(./img/study.png);"> <a class="categoryBar-list-link" href="categories/Study/">Study</a><span class="categoryBar-list-count">24</span><span class="categoryBar-list-descr">Study</span></li><li class="categoryBar-list-item" style="background:url(./img/面试.png);"> <a class="categoryBar-list-link" href="categories/Work/">Work</a><span class="categoryBar-list-count">6</span><span class="categoryBar-list-descr">面试</span></li><li class="categoryBar-list-item" style="background:url(./img/面经.png);"> <a class="categoryBar-list-link" href="categories/面经/">面经</a><span class="categoryBar-list-count">11</span><span class="categoryBar-list-descr">面经</span></li><li class="categoryBar-list-item" style="background:url(./img/work.png);"> <a class="categoryBar-list-link" href="categories/面试/">面试</a><span class="categoryBar-list-count">13</span><span class="categoryBar-list-descr">Work</span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__bounceInLeft');
    arr[i].setAttribute('data-wow-duration', '800ms');
    arr[i].setAttribute('data-wow-delay', '0ms');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__bounceInRight');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/08/04/Project-AIGC广告推荐系统/" alt=""><img width="48" height="48" src="../img/AI.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-04</span><a class="blog-slider__title" href="2024/08/04/Project-AIGC广告推荐系统/" alt="">AIGC 广告推荐系统</a><div class="blog-slider__text">本项目是一个基于 AIGC 的个性化广告推荐系统，区别于传统推荐系统，本系统通过当前流行的人工智能技术，替代了传统的内容过滤和协同过滤等算法，进行广告推荐。</div><a class="blog-slider__button" href="2024/08/04/Project-AIGC广告推荐系统/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/08/27/Study-JVM/" alt=""><img width="48" height="48" src="../img/jvm.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-08-27</span><a class="blog-slider__title" href="2023/08/27/Study-JVM/" alt="">JVM</a><div class="blog-slider__text">JVM学习</div><a class="blog-slider__button" href="2023/08/27/Study-JVM/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/01/05/Study-MySQL高级部分学习/" alt=""><img width="48" height="48" src="../img/mysql.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-01-05</span><a class="blog-slider__title" href="2023/01/05/Study-MySQL高级部分学习/" alt="">MySQL高级部分学习</a><div class="blog-slider__text">用于学习MySQL后续的进阶部分</div><a class="blog-slider__button" href="2023/01/05/Study-MySQL高级部分学习/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/08/03/Study-Redis相关知识/" alt=""><img width="48" height="48" src="../img/redis.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-08-03</span><a class="blog-slider__title" href="2023/08/03/Study-Redis相关知识/" alt="">Redis相关知识</a><div class="blog-slider__text">用于学习Redis相关知识</div><a class="blog-slider__button" href="2023/08/03/Study-Redis相关知识/" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><!-- hexo injector body_end end --></body></html>